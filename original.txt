Script started on Wed 10 May 2017 01:35:54 PM KST
Intel(R) Parallel Studio XE 2017 for Linux*
Copyright (C) 2009-2016 Intel Corporation. All rights reserved.
]0;test10@localhost:~/kmin/nbody[?1034h[test10@localhost nbody]$ ls
[0m[01;32mapp-CPU[0m  [01;32minstructions.txt[0m  [01;32mMakefile[0m  [01;32mnbody.cc[0m  nbody.o.optrpt  original.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ ls[K[Kmakr [K[Ke t[Krun[K[K[K[K[K[K[K[Ksudo [K[K[K[K[Ksudo nano original[Kl.txt
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1             File: original.txt                                 [22;33H[ Read 0 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ script original.txt
Script started, file is original.txt
Intel(R) Parallel Studio XE 2017 for Linux*
Copyright (C) 2009-2016 Intel Corporation. All rights reserved.
]0;test10@localhost:~/kmin/nbody[?1034h[test10@localhost nbody]$ make run-cpu
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  3.361e+01  1.278e+08      2.6 *
    2  3.366e+01  1.276e+08      2.6 *
    3  3.364e+01  1.277e+08      2.6 *
    4  3.362e+01  1.277e+08      2.6 
    5  3.362e+01  1.278e+08      2.6 
    6  3.379e+01  1.271e+08      2.5 
    7  3.374e+01  1.273e+08      2.5 
    8  3.368e+01  1.275e+08      2.6 
    9  3.367e+01  1.276e+08      2.6 
   10  3.364e+01  1.277e+08      2.6 
-----------------------------------------------------
[1mAverage performance:      [42m       2.6 +- 0.0 GFLOP/s[0m
-----------------------------------------------------
* - warm-up, not included in average

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ exit
Script done, file is original.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sid[K[Kudo nano original.txt
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1             File: original.txt                                 [3;1H(B[mScript started on Wed 10 May 2017 01:36:32 PM KST[4dIntel(R) Parallel Studio XE 2017 for Linux*[5dCopyright (C) 2009-2016 Intel Corporation. All rights reserved.[6d^[]0;test10@localhost:~/kmin/nbody^G^[[?1034h[test10@localhost nbody]$ make run$[7;1H./app-CPU 65536[9d^[[1mNBODY Version 00^[[0m[11dPropagating 65536 particles using 1 thread on CPU...[13d^[[1m Step    Time, s Interact/s  GFLOP/s^[[0m[14;5H1  3.361e+01  1.278e+08	 2.6 *[15;5H2  3.366e+01  1.276e+08	 2.6 *[16;5H3  3.364e+01  1.277e+08	 2.6 *[17;5H4  3.362e+01  1.277e+08	 2.6[18;5H5  3.362e+01  1.278e+08	 2.6[19;5H6  3.379e+01  1.271e+08	 2.5[20;5H7  3.374e+01  1.273e+08	 2.5[21;5H8  3.368e+01  1.275e+08	 2.6[22;32H(B[0;7m[ Read 29 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ ds[K[Ksudo nano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleType {[21;3Hfloat x, y, z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat vx, vy, vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle[j].x - particle[i].x;[21;7Hconst float dy = particle[j].y - particle[i].y;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle[j].z - particle[i].z;[13;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[14;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[16;7H// Calculate the net force[17;7HFx += dx / drPower32;[18;7HFy += dy / drPower32;[19;7HFz += dz / drPower32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[21d//#pragma omp parallel for schedule(guided)[12d[13d[14d[15d[16d[17d[18d[19d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d//[1;71H(B[0;7mModified[21;3H(B[m\#pragma omp parallel for schedule(guided)//\\\#pragma omp parallel for schedule(guided)[5G[1P\[1P[1P/[1P[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ scro[Kipt t[KThreadParallelism.txt
Script started, file is ThreadParallelism.txt
Intel(R) Parallel Studio XE 2017 for Linux*
Copyright (C) 2009-2016 Intel Corporation. All rights reserved.
]0;test10@localhost:~/kmin/nbody[?1034h[test10@localhost nbody]$ make run cpu[K[K[K[K-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  3.352e+01  1.281e+08      2.6 *
^Cmake: *** [run-cpu] Interrupt
make: *** Deleting intermediate file `nbody.o'

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ ls
[0m[01;32mapp-CPU[0m           [01;32mMakefile[0m  nbody.o.optrpt  ThreadParallelism.txt
[01;32minstructions.txt[0m  [01;32mnbody.cc[0m  original.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano b[Knd[Kbody.cc
[sudo] password for test10: 
Sorry, try again.
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleType {[21;3Hfloat x, y, z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat vx, vy, vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle[j].x - particle[i].x;[21;7Hconst float dy = particle[j].y - particle[i].y;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle[j].z - particle[i].z;[13;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[14;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[16;7H// Calculate the net force[17;7HFx += dx / drPower32;[18;7HFy += dy / drPower32;[19;7HFz += dz / drPower32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[21d#pragma omp parallel for schedule(guided)[12d[13d[14d[A[A[A[A[A[A[A[A[A[A[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle[j].x - particle[i].x;[11;7Hconst float dy = particle[j].y - particle[i].y;[12;7Hconst float dz = particle[j].z - particle[i].z;[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[A[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle[j].z - particle[i].z;[13;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[14;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[16;7H// Calculate the net force[17;7HFx += dx / drPower32;[18;7HFy += dy / drPower32;[19;7HFz += dz / drPower32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[21d#pragma omp parallel for schedule(guided)[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;1Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle[i].x  += particle[i].vx*dt;[14;5Hparticle[i].y  += particle[i].vy*dt;[15;5Hparticle[i].z  += particle[i].vz*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[13d[A[1;71H(B[0;7mModified[12;8H(B[m[1K	for (int i = 0 ; i < nParticles; i++) {[12;9H[8P for (int i = 0 ; i < nParticles; i++) {   for (int i = 0 ; i < nParticles; i++) {  [A[A[A[A[A  [A[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[4;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[6;7H// Calculate the net force[7;7HFx += dx / drPower32;[8;7HFy += dy / drPower32;[9;7HFz += dz / drPower32;[11;5H}[12d[A  [A[A  [A[A[A[A[A  [A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle[j].x - particle[i].x;[11;7Hconst float dy = particle[j].y - particle[i].y;[12;7Hconst float dz = particle[j].z - particle[i].z;  [A[9d[A[A  [A[A[A[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;3H[A[12d[13d[14d[15d[16d[17d[18d[19d  [20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle[j].z - particle[i].z;[13;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[14;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[16;7H// Calculate the net force[17;7HFx += dx / drPower32;[18;7HFy += dy / drPower32;[19;7HFz += dz / drPower32;[21;5H}[12;3H[13d[14d[15d[16d  [17d[18d[19d[20d[21d  7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[21d#pragma omp parallel for schedule(guided)[12d[13d  [14d[15d[16d[17d[18d[19d  [20d[21d[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1Pided)[Kded)[Ked)[Kd)[K)[K[K[A[21d7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle[i].x  += particle[i].vx*dt;[14;5Hparticle[i].y  += particle[i].vy*dt;[15;5Hparticle[i].z  += particle[i].vz*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[4;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[6;7H// Calculate the net force[7;7HFx += dx / drPower32;[8;7HFy += dy / drPower32;[9;7HFz += dz / drPower32;[11;5H}[12d[A[A[A[A[A[A[A[A[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle[j].x - particle[i].x;[11;7Hconst float dy = particle[j].y - particle[i].y;[12;7Hconst float dz = particle[j].z - particle[i].z;[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[A[A[A[A[A[A[A[A[A[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleType {[11;3Hfloat x, y, z;[12;3Hfloat vx, vy, vz;[A[A[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle[j].x - particle[i].x;[21;7Hconst float dy = particle[j].y - particle[i].y;[12d[A[A[A[A[A[A#pragma	omp parallel for schedule(guod  ided)[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano ThreadParallelism.txt 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1          File: ThreadParallelism.txt                           [3;1H(B[mScript started on Wed 10 May 2017 01:43:07 PM KST[4dIntel(R) Parallel Studio XE 2017 for Linux*[5dCopyright (C) 2009-2016 Intel Corporation. All rights reserved.[6d^[]0;test10@localhost:~/kmin/nbody^G^[[?1034h[test10@localhost nbody]$ make run$[8;1HCompiling a CPU object file:[9dicpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrp$[11;1HLinking the CPU executable:[12dicpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o[13d./app-CPU 65536[15d^[[1mNBODY Version 00^[[0m[17dPropagating 65536 particles using 1 thread on CPU...[19d^[[1m Step    Time, s Interact/s  GFLOP/s^[[0m[20;5H1  3.352e+01  1.281e+08	 2.6 *[21d^Cmake: *** [run-cpu] Interrupt[22d(B[0;7m[ Read 29 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;21r8[10S[1;24r[12;1Hmake: *** Deleting intermediate file `nbody.o'[14d^[]0;test10@localhost:~/kmin/nbody^G[test10@localhost nbody]$ ls[15d^[[0m^[[01;32mapp-CPU^[[0m[15;38H^[[01;32mMakefile^[[0m  nbody.o.optrpt  Th$[16;1H^[[01;32minstructions.txt^[[0m  ^[[01;32mnbody.cc^[[0m  original.txt[17d^[]0;test10@localhost:~/kmin/nbody^G[test10@localhost nbody]$ sudo nano b^H^[[K$[18;1H[sudo] password for test10:[19dSorry, try again.[20d[sudo] password for test10:[21d^[[?1049h^[[1;24r^[(B^[[m^[[4l^[[?7h^[[?12l^[[?25h^[[?1h^[=^[[?1h^[=^[[?1h^[=^[$[12;1H[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[12d[1;71H(B[0;7mModified[11d(B[m$^M^[[21d#pragma omp parallel for schedule(guided)^M^[[12d^[[1[K  [K [Z[K[K[Z[K[K[Z[K[35G[K[11;26H[K[11;15H[K$ccording to their velocities^[[20;3H// O(N) work, so using a serial l[11;53H[K[11;30H[K$*Fy;^[[16;5Hparticle[i].vz += dt*Fz;^[[17;3H}^[[19d^H// Move particles ac[11;38H[K$tional force^[[14;5Hparticle[i].vx += dt*Fx;^[[15;5Hparticle[i].vy[11;17H[K$24r^[[2;1H^[[K^[[13;5H// A$16d  ^[[17[K[3dScript started on Wed 10 May 2017 01:43:07 PM KST[4dIntel(R) Parallel Studio XE 2017 for Linux*[K[5dCopyright (C) 2009-2016 Intel Corporation. All rights reserved.[K[6;3H]0;test10@localhost:~/kmin/nbody^G^[[?1034h[test10@localhost nbody]$ make run$[7;1H[K[8dCompiling a CPU object file:[9dicpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrp$[10;1H[K[11dLinking the CPU executable:[12dicpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o[13d./app-CPU 65536[15d^[[1mNBODY Version 00^[[0m[17dPropagating 65536 particles using 1 thread on CPU...[19d^[[1m Step    Time, s Interact/s  GFLOP/s^[[0m[20;5H1  3.352e+01  1.281e+08	 2.6 *[21d^Cmake: *** [run-cpu] Interrupt[3;50H[4;44H[5;64H[6d$ke run cpu^H^[[K^H^[[K^H^[[K^H^[[K-cpu[K^[]0;test10@localhost:~/kmin/nbody^G^[[?1034h[test10@localhost nbody]$ make run$[7;1H[8;29H[9d$.optrpt -o "nbody.o" "nbody.cc"[Kicpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrp$[10;1H[11;28H[12;51H[13;16H[14d[15;27H[16d[17;53H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: ThreadParallelism.txt                   [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;42H[6G(B[0;7mwas modified since you opened it, continue saving ?[23d Y(B[m Yes[K[24d(B[0;7m N(B[m No    	(B[0;7m^C(B[m Cancel[K[22;58H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;31H(B[m[1K (B[0;7m[ Wrote 29 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ 
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo rm ThreadParallelism.txt 
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ ls
[0m[01;32mapp-CPU[0m  [01;32minstructions.txt[0m  [01;32mMakefile[0m  [01;32mnbody.cc[0m  nbody.o.optrpt  original.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ scrop[K[Kipt Trhea[K[K[Kead[K[K[K[KhreadParallelism.txt
Script started, file is ThreadParallelism.txt
Intel(R) Parallel Studio XE 2017 for Linux*
Copyright (C) 2009-2016 Intel Corporation. All rights reserved.
]0;test10@localhost:~/kmin/nbody[?1034h[test10@localhost nbody]$ make run-cpi[Ku

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  3.408e-01  1.260e+10    252.0 *
    2  2.698e-01  1.592e+10    318.3 *
    3  2.653e-01  1.619e+10    323.8 *
    4  2.797e-01  1.536e+10    307.2 
    5  2.715e-01  1.582e+10    316.4 
    6  2.714e-01  1.583e+10    316.5 
    7  2.704e-01  1.588e+10    317.7 
    8  2.644e-01  1.624e+10    324.9 
    9  2.678e-01  1.604e+10    320.7 
   10  2.705e-01  1.588e+10    317.5 
-----------------------------------------------------
[1mAverage performance:      [42m     317.3 +- 5.0 GFLOP/s[0m
-----------------------------------------------------
* - warm-up, not included in average

rm nbody.o
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ exit
Script done, file is ThreadParallelism.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleType {[21;3Hfloat x, y, z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat vx, vy, vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle[j].x - particle[i].x;[21;7Hconst float dy = particle[j].y - particle[i].y;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle[j].z - particle[i].z;[13;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[14;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[16;7H// Calculate the net force[17;7HFx += dx / drPower32;[18;7HFy += dy / drPower32;[19;7HFz += dz / drPower32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle[i].x  += particle[i].vx*dt;[14;5Hparticle[i].y  += particle[i].vy*dt;[15;5Hparticle[i].z  += particle[i].vz*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleType* particle = new ParticleType[nParticles];[21;3H// Initialize random number generator and particles[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3HVSLStreamStatePtr rnStream;[13;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[14;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[15;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[17;3H// Perform benchmark[18;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[19;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[20;10HnParticles,[21d#ifndef __MIC__[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;10H"CPU"[13d#else[14d	 "MIC"[15d#endif[16d	 );[17;3Hdouble rate = 0, dRate = 0; // Benchmarking data[18;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[19;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[20;3Hfor (int step = 1; step <= nSteps; step++) {[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d[A[A[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hconst double tStart = omp_get_wtime(); // Start timing[13;5HMoveParticles(nParticles, particle, dt);[14;5Hconst double tEnd = omp_get_wtime(); // End timing[16;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[17;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[19;5Hif (step > skipSteps) { // Collect statistics[20;7Hrate  += HztoGFLOPs/(tEnd - tStart);[21;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5H}[14dprintf("%5d %10.3e %10.3e %8.1f %s\n",[15;12Hstep, (tEnd-tStart), HztoInts/(tEnd-tStart), HztoGFLOPs/(tEnd-tStart$[16;5Hfflush(stdout);[17;3H}[18drate/=(double)(nSteps-skipSteps);[19;3HdRate=sqrt(dRate/(double)(nSteps-skipSteps)-rate*rate);[20;3Hprintf("-----------------------------------------------------\n");[21;3Hprintf("\033[1m%s %4s \033[42m%10.1f +- %.1f GFLOP/s\033[0m\n",[12d[13d[14d[15d[16d[17d[A[A[A[A[A[A[A[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[12;10H"Average performance:", "", rate, dRate);[13;3Hprintf("-----------------------------------------------------\n");[14;3Hprintf("* - warm-up, not included in average\n\n");[15;3Hdelete particle;[16d}[12d[13d[14d[15d[16d[17d[18d[19d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;5HMoveParticles(nParticles, particle, dt);[4;5Hconst double tEnd = omp_get_wtime(); // End timing[6;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[7;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[9;5Hif (step > skipSteps) { // Collect statistics[10;7Hrate  += HztoGFLOPs/(tEnd - tStart);[11;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12;5H}[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;1H#else[4d	 "MIC"[5d#endif[6d	 );[7;3Hdouble rate = 0, dRate = 0; // Benchmarking data[8;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[9;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[10;3Hfor (int step = 1; step <= nSteps; step++) {[12;5Hconst double tStart = omp_get_wtime(); // Start timing[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[4;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[5;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[7;3H// Perform benchmark[8;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[9;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[10;10HnParticles,[11d#ifndef __MIC__[12;10H"CPU"[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;3Hconst int nSteps = 10;  // Duration of test[4;3Hconst float dt = 0.01f; // Particle propagation time step[6;3H// Particle data stored as an Array of Structures (AoS)[7;3H// this is good object-oriented programming style,[8;3H// but inefficient for the purposes of vectorization[9;3HParticleType* particle = new ParticleType[nParticles];[11;3H// Initialize random number generator and particles[12;3HVSLStreamStatePtr rnStream;[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;5Hparticle[i].x  += particle[i].vx*dt;[4;5Hparticle[i].y  += particle[i].vy*dt;[5;5Hparticle[i].z  += particle[i].vz*dt;[6;3H}[7d}[9dint main(const int argc, const char** argv) {[11;3H// Problem size and other parameters[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;5H// Accelerate particles in response to the gravitational force[4;5Hparticle[i].vx += dt*Fx;[5;5Hparticle[i].vy += dt*Fy;[6;5Hparticle[i].vz += dt*Fz;[7;3H}[9d// Move particles according to their velocities[10;3H// O(N) work, so using a serial loop[12;3Hfor (int i = 0 ; i < nParticles; i++) {[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[4;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[6;7H// Calculate the net force[7;7HFx += dx / drPower32;[8;7HFy += dy / drPower32;[9;7HFz += dz / drPower32;[11;5H}[12d[A[A[A[A[A[A[A[A[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle[j].x - particle[i].x;[11;7Hconst float dy = particle[j].y - particle[i].y;[12;7Hconst float dz = particle[j].z - particle[i].z;[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[6;1H#pragma omp parallel for schedule(guided)[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[A[A[A[A[A[A[A[A[A[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleType {[11;3Hfloat x, y, z;[12;3Hfloat vx, vy, vz;[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;1H/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[12d[A[A[A[A[A[A[A[A[A[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3Hfloat vx, vy, vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle[j].x - particle[i].x;[21;7Hconst float dy = particle[j].y - particle[i].y;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle[j].z - particle[i].z;[13;7Hconst float drSquared  = dx*dx + dy*dy + dz*dz + softening;[14;7Hconst float drPower32  = pow(drSquared, 3.0/2.0);[16;7H// Calculate the net force[17;7HFx += dx / drPower32;[18;7HFy += dy / drPower32;[19;7HFz += dz / drPower32;[21;5H}[12d[13d      c	nst flo	t drSqu	redd[1;71H(B[0;7mModified[13;27H(B[m[1P[1P[Z[1P[1P[1P[1P[1PR  = dx*dx + dy*dy + dz*dz + softening;[13;22He  = dx*dx + dy*dy + dz*dz + softening;[13;23Hc  = dx*dx + dy*dy + dz*dz + softening;[13;24Hi  = dx*dx + dy*dy + dz*dz + softening;[13;25Hp  = dx*dx + dy*dy + dz*dz + softening;[13;26H  = d1dx*dx + dy*dy + dz*dz + softening;[13;31H.dx*dx + dy*dy + dz*dz + softening;[13;32H0dx*dx + dy*dy + dz*dz + softening;[13;33Hfdx*dx + dy*dy + dz*dz + softening;[13;34H/dx*dx + dy*dy + dz*dz + softening;[13;35Hsdx*dx + dy*dy + dz*dz + softening;[13;36Hqdx*dx + dy*dy + dz*dz + softening;[13;37Hrdx*dx + dy*dy + dz*dz + softening;[13;38Htdx*dx + dy*dy + dz*dz + softening;[13;39Hfdx*dx + dy*dy + dz*dz + softening;[13;40H(dx*dx + dy*dy + dz*dz + softening;[13;41Hdx*dx +	dy*dy +	dz*dz ++	softeni	g);[Zg[Z);[K[Z);[K[Z);[K);[K);[K);[K);[K);[K[Z);[K[Z1);e);-);2);0);f);[14;56H[15;9H[14;56H;[K;[K;[K;[K;[K[Z;[K[Z;[K;[K;[K;[K;[K;[K;[K[Z;[K[Z;[K;[K;[K;[K;[K;[K;[K[Z;[K[Z;[Kd;[Zf;[Z;[K[Zr;R;e;c;i;p;*;d;[Zr;R;e;c;i;p;*;d;[Ze;[Z;[K[Zr;R;e;c;i;p;[15;9H[16;33H[17;30H[18d[A[Z[A[15;9H[14;21HPow	rN32  = drRecip*drRecip*drRecip;[14;27H[16d[17d[Z	N32;[18d[ZN32;[19d[ZN32;[A[Z[A[Z[1P* drPowerN32;[17;17H[18d[1P* drPowerN32;[18;17H[19d[1P* drPowerN32;[19;17H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ script ScalarTuning.txt
Script started, file is ScalarTuning.txt
Intel(R) Parallel Studio XE 2017 for Linux*
Copyright (C) 2009-2016 Intel Corporation. All rights reserved.
]0;test10@localhost:~/kmin/nbody[?1034h[test10@localhost nbody]$ make rup[Kn-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  2.553e-01  1.683e+10    336.5 *
    2  1.785e-01  2.406e+10    481.2 *
    3  1.793e-01  2.395e+10    479.0 *
    4  1.783e-01  2.408e+10    481.7 
    5  1.807e-01  2.376e+10    475.3 
    6  1.904e-01  2.255e+10    451.1 
    7  1.806e-01  2.378e+10    475.6 
    8  1.791e-01  2.398e+10    479.5 
    9  1.813e-01  2.369e+10    473.8 
   10  1.811e-01  2.372e+10    474.4 
-----------------------------------------------------
[1mAverage performance:      [42m     473.1 +- 9.4 GFLOP/s[0m
-----------------------------------------------------
* - warm-up, not included in average

rm nbody.o
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ exit
Script done, file is ScalarTuning.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano ThreadParallelism.txt 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1          File: ThreadParallelism.txt                           [3;1H(B[mScript started on Wed 10 May 2017 01:47:04 PM KST[4dIntel(R) Parallel Studio XE 2017 for Linux*[5dCopyright (C) 2009-2016 Intel Corporation. All rights reserved.[6d^[]0;test10@localhost:~/kmin/nbody^G^[[?1034h[test10@localhost nbody]$ make run$[8;1HCompiling a CPU object file:[9dicpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrp$[11;1HLinking the CPU executable:[12dicpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o[13d./app-CPU 65536[15d^[[1mNBODY Version 00^[[0m[17dPropagating 65536 particles using 1 thread on CPU...[19d^[[1m Step    Time, s Interact/s  GFLOP/s^[[0m[20;5H1  3.408e-01  1.260e+10    252.0 *[21;5H2  2.698e-01  1.592e+10    318.3 *[22;32H(B[0;7m[ Read 36 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;21r8[10S[1;24r[12;5H3  2.653e-01  1.619e+10    323.8 *[13;5H4  2.797e-01  1.536e+10    307.2[14;5H5  2.715e-01  1.582e+10    316.4[15;5H6  2.714e-01  1.583e+10    316.5[16;5H7  2.704e-01  1.588e+10    317.7[17;5H8  2.644e-01  1.624e+10    324.9[18;5H9  2.678e-01  1.604e+10    320.7[19;4H10  2.705e-01  1.588e+10    317.5[20d-----------------------------------------------------[21d^[[1mAverage performance:[32G^[[42m     317.3 +- 5.0 GFLOP/s^[[0m[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbodt[Ky.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleType {[21;3Hfloat x, y, z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat vx, vy, vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[A[A[A [22d[K[11d  float	[1;71H(B[0;7mModified[11;9H(B[m*x, y, z;[11;10Hx, *y, z;[14Gy,	*z;[12d[Z*vz;[Z*vy, *vz;[12;14H	*vx, *vy, *vz;[12;10H[13;3H[14d[15;10H[16d[17d[18d[19d[20;10H[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle[j].x - particle[i].x;[21;7Hconst float dy = particle[j].y - particle[i].y;[12;7H[13d	o[14d[15;7H[16d	 [17d[18d[19;10H[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle[j].z - particle[i].z;[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;10H[As[At flo	t dx = 	article	j].[1P[1P[Z[1P[1P.x - particle[i].x;[10;33Hx[ - particle[i].x;[10;35Hj - particle[i].x;[10;36H] - particle[i].x;[10;37H - 	article	i]..x;[K[Z.x;[K[Z.x;[K[Z	x;[;i;];[11d[Z[Z[1P[Z[1P[1P	y[ - particle[i].y;[11;35Hj - particle[i].y;[11;36H] - particle[i].y;[11;37H - 	article	i].y;[K[Z.y;[K[Z.y;[K[Z	y;[;i;];[12d[Z[Z[1P[Z[1P[1P	z[ - particle[i].z;[12;35Hj - particle[i].z;[12;36H] - particle[i].z;[12;37H - 	article	i]..z;[K[Z.z;[K[Z.z;[K[Z	z[;i;];[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ script Vectorization.txt
Script started, file is Vectorization.txt
Intel(R) Parallel Studio XE 2017 for Linux*
Copyright (C) 2009-2016 Intel Corporation. All rights reserved.
]0;test10@localhost:~/kmin/nbody[?1034h[test10@localhost nbody]$ make run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must have integral or enum type
      particle[i].vx += dt*Fx; 
                        ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have arithmetic or enum type
      particle[i].x  += particle[i].vx*dt;
                        ^

nbody.cc(62): error: expression must have arithmetic or enum type
      particle[i].y  += particle[i].vy*dt;
                        ^

nbody.cc(63): error: expression must have arithmetic or enum type
      particle[i].z  += particle[i].vz*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpu[1Pvi nbody.ccls[Kvi nbody.cc[1P nbody.cc[1P nbody.ccs nbody.ccu nbody.ccd nbody.cco nbody.cc[C nbody.ccn nbody.cca nbody.ccn nbody.cco nbody.cc
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleType {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[A    par	[15d[16d[17;4H[18d[19;9H[20d[21d 7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle[i].x  += particle[i].vx*dt;[14;5Hparticle[i].y  += particle[i].vy*dt;[15;5Hparticle[i].z  += particle[i].vz*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12;9H[13dicle[i]	[1;71H(B[0;7mModified[13;16H(B[m[1P[1P[1P[1P.x  += particle[i].vx*dt;[13;14Hx[  += particle[i].vx*dt;[13;16Hi]  += particle[i].vx*dt;[13;18H[14d[Z	[1P[1P[1P.y[  += particle[i].vy*dt;[14;16Hi  += particle[i].vy*dt;[14;17H]  += particle[i].vy*dt;[14;18H[15d[Z\.z  += particle[i].vz*dt;[15;17H[1P[1P[1P[1P.z[  += particle[i].vz*dt;[15;16Hi  += particle[i].vz*dt;[15;17H]  += particle[i].vz*dt;[15;18H[16;4H[17d[18d[19;18H[20d[21;18H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleType* particle = new ParticleType[nParticles];[21;3H// Initialize random number generator and particles[12;18H[13d[14d[15d[16;18H[17d[18d[19d[20d[21;18H7[3;22r8[22d[10S[1;24r[12;3HVSLStreamStatePtr rnStream;[13;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[14;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[15;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[17;3H// Perform benchmark[18;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[19;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[20;10HnParticles,[21d#ifndef __MIC__[12;18H[13d[14d[15d[16;3H[17;18H[18d[19d[20d[21;16H7[3;22r8[22d[10S[1;24r[12;10H"CPU"[13d#else[14d	 "MIC"[15d#endif[16d	 );[17;3Hdouble rate = 0, dRate = 0; // Benchmarking data[18;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[19;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[20;3Hfor (int step = 1; step <= nSteps; step++) {[12;15H[13;6H[14;15H[15;7H[16;12H[17d	0[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hconst double tStart = omp_get_wtime(); // Start timing[13;5HMoveParticles(nParticles, particle, dt);[14;5Hconst double tEnd = omp_get_wtime(); // End timing[16;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[17;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[19;5Hif (step > skipSteps) { // Collect statistics[20;7Hrate  += HztoGFLOPs/(tEnd - tStart);[21;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12;18H[13d[14d[15d[16;18H[17d[18d[19;18H[20d[21d7[3;22r8[22d[10S[1;24r[12;5H}[14dprintf("%5d %10.3e %10.3e %8.1f %s\n",[15;12Hstep, (tEnd-tStart), HztoInts/(tEnd-tStart), HztoGFLOPs/(tEnd-tStart$[16;5Hfflush(stdout);[17;3H}[18drate/=(double)(nSteps-skipSteps);[19;3HdRate=sqrt(dRate/(double)(nSteps-skipSteps)-rate*rate);[20;3Hprintf("-----------------------------------------------------\n");[21;3Hprintf("\033[1m%s %4s \033[42m%10.1f +- %.1f GFLOP/s\033[0m\n",[12;6H[13d[14;18H[15d[16d[17;4H[18;18H[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[12;10H"Average performance:", "", rate, dRate);[13;3Hprintf("-----------------------------------------------------\n");[14;3Hprintf("* - warm-up, not included in average\n\n");[15;3Hdelete particle;[16d}[12;18H[A[A[A[A[A  }[6;18H[A[A[A[2;21r[2;1H[10T[1;24r[3;5HMoveParticles(nParticles, particle, dt);[4;5Hconst double tEnd = omp_get_wtime(); // End timing[6;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[7;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[9;5Hif (step > skipSteps) { // Collect statistics[10;7Hrate  += HztoGFLOPs/(tEnd - tStart);[11;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12;5H}[11;18H[A[A[A[7;18H[A[A[4;18H[A[2;21r[2;1H[10T[1;24r[3;1H#else[4d	 "MIC"[5d#endif[6d	 );[7;3Hdouble rate = 0, dRate = 0; // Benchmarking data[8;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[9;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[10;3Hfor (int step = 1; step <= nSteps; step++) {[12;5Hconst double tStart = omp_get_wtime(); // Start timing[12;18H[A[10;18H[A[A[A[6;12H[5;7H[4;15H[3;6H[2;21r[2;1H[10T[1;24r[3;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[4;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[5;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[7;3H// Perform benchmark[8;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[9;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[10;10HnParticles,[11d#ifndef __MIC__[12;10H"CPU"[A_[2;21r[2;1H[10T[1;24r[3;3Hconst int nSteps = 10;  // Duration of test[4;3Hconst float dt = 0.01f; // Particle propagation time step[6;3H// Particle data stored as an Array of Structures (AoS)[7;3H// this is good object-oriented programming style,[8;3H// but inefficient for the purposes of vectorization[9;3HParticleType* particle = new ParticleType[nParticles];[11;3H// Initialize random number generator and particles[12;3HVSLStreamStatePtr rnStream;[11;18H[A[9;18H[A[A[A[A[4;18H[A[2;21r[2;1H[10T[1;24r[3;5Hparticle.x[i]  += particle[i].vx*dt;[4;5Hparticle.y[i]  += particle[i].vy*dt;[5;5Hparticle.z[i]  += particle[i].vz*dt;[6;3H}[7d}[9dint main(const int argc, const char** argv) {[11;3H// Problem size and other parameters[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[12;18H[A[A[9;18H[A[A}[A }[5;18H[A[A[2;21r[2;1H[10T[1;24r[3;5H// Accelerate particles in response to the gravitational force[4;5Hparticle[i].vx += dt*Fx;[5;5Hparticle[i].vy += dt*Fy;[6;5Hparticle[i].vz += dt*Fz;[7;3H}[9d// Move particles according to their velocities[10;3H// O(N) work, so using a serial loop[12;3Hfor (int i = 0 ; i < nParticles; i++) {[12;18H[A [22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must have integral or enum type
      particle[i].vx += dt*Fx; 
                        ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle[i].vx*dt;
      ^

nbody.cc(61): error: expression must have arithmetic or enum type
      particle.x[i]  += particle[i].vx*dt;
                        ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle[i].vy*dt;
      ^

nbody.cc(62): error: expression must have arithmetic or enum type
      particle.y[i]  += particle[i].vy*dt;
                        ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle[i].vz*dt;
      ^

nbody.cc(63): error: expression must have arithmetic or enum type
      particle.z[i]  += particle[i].vz*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpusudo nano nbody.cc
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleType {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle[i].vx*dt;[14;5Hparticle.y[i]  += particle[i].vy*dt;[15;5Hparticle.z[i]  += particle[i].vz*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[13d[14d[15d[16d[17d[18d[19d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[4;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[6;7H// Calculate the net force[7;7HFx += dx * drPowerN32;[8;7HFy += dy * drPowerN32;[9;7HFz += dz * drPowerN32;[11;5H}[12d[A[A[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle[i].vx*dt;[14;5Hparticle.y[i]  += particle[i].vy*dt;[15;5Hparticle.z[i]  += particle[i].vz*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleType* particle = new ParticleType[nParticles];[21;3H// Initialize random number generator and particles[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3HVSLStreamStatePtr rnStream;[13;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[14;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[15;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[17;3H// Perform benchmark[18;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[19;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[20;10HnParticles,[21d#ifndef __MIC__[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;10H"CPU"[13d#else[14d	 "MIC"[15d#endif[16d	 );[17;3Hdouble rate = 0, dRate = 0; // Benchmarking data[18;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[19;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[20;3Hfor (int step = 1; step <= nSteps; step++) {[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hconst double tStart = omp_get_wtime(); // Start timing[13;5HMoveParticles(nParticles, particle, dt);[14;5Hconst double tEnd = omp_get_wtime(); // End timing[16;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[17;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[19;5Hif (step > skipSteps) { // Collect statistics[20;7Hrate  += HztoGFLOPs/(tEnd - tStart);[21;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5H}[14dprintf("%5d %10.3e %10.3e %8.1f %s\n",[15;12Hstep, (tEnd-tStart), HztoInts/(tEnd-tStart), HztoGFLOPs/(tEnd-tStart$[16;5Hfflush(stdout);[17;3H}[18drate/=(double)(nSteps-skipSteps);[19;3HdRate=sqrt(dRate/(double)(nSteps-skipSteps)-rate*rate);[20;3Hprintf("-----------------------------------------------------\n");[21;3Hprintf("\033[1m%s %4s \033[42m%10.1f +- %.1f GFLOP/s\033[0m\n",[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[12;10H"Average performance:", "", rate, dRate);[13;3Hprintf("-----------------------------------------------------\n");[14;3Hprintf("* - warm-up, not included in average\n\n");[15;3Hdelete particle;[16d}[12d[13d[14d[15d[16d[17d[18d[19d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;5HMoveParticles(nParticles, particle, dt);[4;5Hconst double tEnd = omp_get_wtime(); // End timing[6;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[7;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[9;5Hif (step > skipSteps) { // Collect statistics[10;7Hrate  += HztoGFLOPs/(tEnd - tStart);[11;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12;5H}[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;1H#else[4d	 "MIC"[5d#endif[6d	 );[7;3Hdouble rate = 0, dRate = 0; // Benchmarking data[8;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[9;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[10;3Hfor (int step = 1; step <= nSteps; step++) {[12;5Hconst double tStart = omp_get_wtime(); // Start timing[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[4;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[5;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[7;3H// Perform benchmark[8;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[9;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[10;10HnParticles,[11d#ifndef __MIC__[12;10H"CPU"[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;3Hconst int nSteps = 10;  // Duration of test[4;3Hconst float dt = 0.01f; // Particle propagation time step[6;3H// Particle data stored as an Array of Structures (AoS)[7;3H// this is good object-oriented programming style,[8;3H// but inefficient for the purposes of vectorization[9;3HParticleType* particle = new ParticleType[nParticles];[11;3H// Initialize random number generator and particles[12;3HVSLStreamStatePtr rnStream;[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;5Hparticle.x[i]  += particle[i].vx*dt;[4;5Hparticle.y[i]  += particle[i].vy*dt;[5;5Hparticle.z[i]  += particle[i].vz*dt;[6;3H}[7d}[9dint main(const int argc, const char** argv) {[11;3H// Problem size and other parameters[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;5H// Accelerate particles in response to the gravitational force[4;5Hparticle[i].vx += dt*Fx;[5;5Hparticle[i].vy += dt*Fy;[6;5Hparticle[i].vz += dt*Fz;[7;3H}[9d// Move particles according to their velocities[10;3H// O(N) work, so using a serial loop[12;3Hfor (int i = 0 ; i < nParticles; i++) {[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[4;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[6;7H// Calculate the net force[7;7HFx += dx * drPowerN32;[8;7HFy += dy * drPowerN32;[9;7HFz += dz * drPowerN32;[11;5H}[12d[A[A[A[A[A[A[A[A[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[A[A[A[A[A[A[A[A[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc[6Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must have integral or enum type
      particle[i].vx += dt*Fx; 
                        ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle[i].vx*dt;
      ^

nbody.cc(61): error: expression must have arithmetic or enum type
      particle.x[i]  += particle[i].vx*dt;
                        ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle[i].vy*dt;
      ^

nbody.cc(62): error: expression must have arithmetic or enum type
      particle.y[i]  += particle[i].vy*dt;
                        ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle[i].vz*dt;
      ^

nbody.cc(63): error: expression must have arithmetic or enum type
      particle.z[i]  += particle[i].vz*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpusudo nano nbody.cc
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleType {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20dstruct 	[22d[K[20;10Hrticle	ype[1;71H(B[0;7mModified[20;19H(B[m {[K {[K[Z {[K[Z {[K[ZS {[Ze {t {[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc[6Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(23): error: identifier "ParticleType" is undefined
  void MoveParticles(const int nParticles, ParticleType* const particle, const float dt) {
                                           ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle[i].vx*dt;
      ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle[i].vy*dt;
      ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle[i].vz*dt;
      ^

nbody.cc(77): error: identifier "ParticleType" is undefined
    ParticleType* particle = new ParticleType[nParticles];
    ^

nbody.cc(77): error: identifier "particle" is undefined
    ParticleType* particle = new ParticleType[nParticles];
                  ^

nbody.cc(77): error: expected a type specifier
    ParticleType* particle = new ParticleType[nParticles];
                                 ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpu[Kmake run-cpusudo nano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleType* const particle, const fl$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[A[22d[K[15dvoid Mo	ePartic	es(cons	 int nP	rticles	 Partic	eType[1;71H(B[0;7mModified[15;53H(B[m* const particle, const flo[15;53H* const particle, const floa[15;52H* const particle, const float[15;51H* const particle, const float [15;50HS* const particle, const float[15;51He* const particle, const floa[15;52Ht* const particle, const flo[15;53H* c	nst par	icle, c	nst[16;42H[17;47H[18;42H[19d[20;53H[21;35H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12;7H[13;73H[14;44H[15;7H[16;53H[17;37H[18d[19;43H[20;54H[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;54H[13;73H[14;57H[15;9H[16;33H[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;67H[14;30H[15d[16d[17;4H[18d[19;50H[20;39H[21d 7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle[i].vx*dt;[14;5Hparticle.y[i]  += particle[i].vy*dt;[15;5Hparticle.z[i]  += particle[i].vz*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12;43H[13;41H[14d[15d[16;4H[17d[18d[19;46H[20d[21;39H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleType* particle = new ParticleType[nParticles];[21;3H// Initialize random number generator and particles[12;61H[13;46H[14;60H[15d[16;58H[17;53H[18don[19d	[Z[Z[Z[Z[Z[1P[1P[1PSe* particle = new ParticleType[nParticles];[19;12Het* particle = new ParticleType[nParticles];[19;14H* 	article	= new P	rticleT	p[Z[1P[1P[1PSe[nParticles];[19;40H	t[nParticles];[19;42H[20d[21;42H7[3;22r8[22d[10S[1;24r[12;3HVSLStreamStatePtr rnStream;[13;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[14;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[15;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[17;3H// Perform benchmark[18;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[19;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[20;10HnParticles,[21d#ifndef __MIC__[12;32H[13;42H[14d[15d[16;3H[17;23H[18;42H[19d[20;21H[21;16H7[3;22r8[22d[10S[1;24r[12;10H"CPU"[13d#else[14d	 "MIC"[15d#endif[16d	 );[17;3Hdouble rate = 0, dRate = 0; // Benchmarking data[18;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[19;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[20;3Hfor (int step = 1; step <= nSteps; step++) {[12;15H[13;6H[14;15H[15;7H[16;12H[17;42H[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hconst double tStart = omp_get_wtime(); // Start timing[13;5HMoveParticles(nParticles, particle, dt);[14;5Hconst double tEnd = omp_get_wtime(); // End timing[16;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[17;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[19;5Hif (step > skipSteps) { // Collect statistics[20;7Hrate  += HztoGFLOPs/(tEnd - tStart);[21;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12;42H[13d[14d[15d[16;42H[17d[18d[19;42H[20d[21d7[3;22r8[22d[10S[1;24r[12;5H}[14dprintf("%5d %10.3e %10.3e %8.1f %s\n",[15;12Hstep, (tEnd-tStart), HztoInts/(tEnd-tStart), HztoGFLOPs/(tEnd-tStart$[16;5Hfflush(stdout);[17;3H}[18drate/=(double)(nSteps-skipSteps);[19;3HdRate=sqrt(dRate/(double)(nSteps-skipSteps)-rate*rate);[20;3Hprintf("-----------------------------------------------------\n");[21;3Hprintf("\033[1m%s %4s \033[42m%10.1f +- %.1f GFLOP/s\033[0m\n",[12;6H[13d[14;42H[15d[16;20H[17;4H[18;37H[19d	t[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[12;10H"Average performance:", "", rate, dRate);[13;3Hprintf("-----------------------------------------------------\n");[14;3Hprintf("* - warm-up, not included in average\n\n");[15;3Hdelete particle;[16d}[12;42H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc[6Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must have integral or enum type
      particle[i].vx += dt*Fx; 
                        ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle[i].vx*dt;
      ^

nbody.cc(61): error: expression must have arithmetic or enum type
      particle.x[i]  += particle[i].vx*dt;
                        ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle[i].vy*dt;
      ^

nbody.cc(62): error: expression must have arithmetic or enum type
      particle.y[i]  += particle[i].vy*dt;
                        ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle[i].vz*dt;
      ^

nbody.cc(63): error: expression must have arithmetic or enum type
      particle.z[i]  += particle[i].vz*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpusudo nano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[A[A[A[A[A[A[A[A[A[A[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz;[A[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d   [13d[14d[15d[16d[17d[18d[19;4H[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d   c	nst f[13d[14d[15d	[16;14H[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;14H[14d[15d[16d[17;4H[18d[19;14H[20d[21d 7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle[i].vx*dt;[14;5Hparticle.y[i]  += particle[i].vy*dt;[15;5Hparticle.z[i]  += particle[i].vz*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12;14H[13dx[	]  += p	rticle[	].v[1;71H(B[0;7mModified[13;34H(B[m[1P[Z[1P[1P[1Pv	.vx*dt;[Z	x[*dt;i*dt;]*dt;[14d[Z[1P[1P[1P.	y[*dt;i*dt;]*dt;[15d[Z[1P[1P[1P.	z[*dt;i*dt;]*dt;[16;4H[17d[18d[19;37H[20d[21;37H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[nParticles];[21;3H// Initialize random number generator and particles[12;37H[13d[14d[15d[16;37H[17d[18d[19d[20d[21;37H7[3;22r8[22d[10S[1;24r[12;3HVSLStreamStatePtr rnStream;[13;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[14;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[15;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[17;3H// Perform benchmark[18;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[19;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[20;10HnParticles,[21d#ifndef __MIC__[12;32H[13;37H[14d[15d[16;3H[17;23H[18;37H[19d[20;21H[21;16H7[3;22r8[22d[10S[1;24r[12;10H"CPU"[13d#else[14d	 "MIC"[15d#endif[16d	 );[17;3Hdouble rate = 0, dRate = 0; // Benchmarking data[18;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[19;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[20;3Hfor (int step = 1; step <= nSteps; step++) {[12;15H[13;6H[14;15H[15;7H[16;12H[17;37H[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hconst double tStart = omp_get_wtime(); // Start timing[13;5HMoveParticles(nParticles, particle, dt);[14;5Hconst double tEnd = omp_get_wtime(); // End timing[16;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[17;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[19;5Hif (step > skipSteps) { // Collect statistics[20;7Hrate  += HztoGFLOPs/(tEnd - tStart);[21;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12;37H[13d[14d[15d[16;37H[17d[18d[19;37H[20d[21d7[3;22r8[22d[10S[1;24r[12;5H}[14dprintf("%5d %10.3e %10.3e %8.1f %s\n",[15;12Hstep, (tEnd-tStart), HztoInts/(tEnd-tStart), HztoGFLOPs/(tEnd-tStart$[16;5Hfflush(stdout);[17;3H}[18drate/=(double)(nSteps-skipSteps);[19;3HdRate=sqrt(dRate/(double)(nSteps-skipSteps)-rate*rate);[20;3Hprintf("-----------------------------------------------------\n");[21;3Hprintf("\033[1m%s %4s \033[42m%10.1f +- %.1f GFLOP/s\033[0m\n",[12;6H[13d[14;37H[15d[16;20H[17;4H[18;37H[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[12;10H"Average performance:", "", rate, dRate);[13;3Hprintf("-----------------------------------------------------\n");[14;3Hprintf("* - warm-up, not included in average\n\n");[15;3Hdelete particle;[16d}[12;37H[13d[14d[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc[6Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must have integral or enum type
      particle[i].vx += dt*Fx; 
                        ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
      ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
                        ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
      ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
                        ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
      ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpusudo nano nbody.cc
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d    p[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4dT[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d#[15d[16d[17d[18d[19d[20ds[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d [13d[14d[15dv[16d[17d[22d[K[18d [19d[20d [21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d [13d[14d[15d[16d[17d[18d[19d [20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d [13d[14d[15d[A [A[A[13d[14d[15d[16d [17d[18d[19d[A[A     F	 += [23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[A[A[14d[15d[A    par	icle[i]	vx += x += d	[A[A[11;6H[A[9;25H[A[A[A[5;9H[4;25H[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;25H[A[A[A[A[7;25H[A[5;7H[4;25H[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[6;1H#pragma omp parallel for schedule(guided)[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;7H[11;25H[A[A[8;25H[A[A[A[A[A};[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz; [A[A{ [A[8;17H[9d[10;22H[11d[12;24H[13;3H[14d[15;25H[16d[17d[18d[19d[20;25H[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12;7H[13;25H[14d[15;7H[16;25H[17d[18d[19;25H[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;25H[13d[14d[15;9H[16;25H[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;25H[14d[A[A[11;6H[A[9;25H[A[A[A[5;9H[4;25H[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;25H[A[A[A[A[7;25H[A[5;7H[4;25H[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[6;1H#pragma omp parallel for schedule(guided)[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;7H[11;25H[A[A[8;25H[A[A[A[A[A};[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz; [A[12;24H[13;3H[14d[15;25H[16d[A int nP	rticles	 Partic	eSet* c	nst par	icle, c	nst fl$st float dt) {[K[Z	t dt) {void MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#[A$st float dt) {[K	void MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[15;79Hfl$st float dt) {[K[Z	t	void MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[15;79H[Z[Z[Z[Z[Z[Z[16d[17d[18d[A[18d[19d[20;26H[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12;7H[13;26H[14d[15;7H[16;26H[17d[18d[19;26H[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;26H[13d[14d[15;9H[16;26H[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;26H[14d[Z[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc[6Pmake run-cpusudo nano nbody.cc
[sudo] password for test10: 
Sorry, try again.
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz;[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d[A[21d[A      c	nst flo	t dx = 	article	[A[A[17;32H[A[15;7H[14;32H[A[12;7H[11;32H[A[A[8;32H[A[A[A[A[A};[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz; [A[A{ [A[8;17H[Al.h>[A[A[Z[Ab>[A[2;21r[2;1H[10T[1;24r[3;1H/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[12d[11;32H[A[A[A[A[A[A[6d[7d[8d[9d[10d[11d[12d[13d[14;19H[15;17H[16d>[17;21H[18;17H[19d[20;22H[21d7[2;22r8[22d[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;24H[13;3H[14d[15;32H[16d[17d[18d[19d[20;32H[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12;7H[13;32H[14d[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc[6Pmake run-cpusudo nano nbody.cc
[sudo] password for test10: 
Sorry, try again.
[sudo] password for test10: 
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d      c	nst flo	t[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;18H[13d[14d[15;9H[16;18H[17d[18d[19d[20d[19;18H[A[A[Z[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;14H[14di]	vx += [15d[16d[17;4H[18d[19;23H[20d[21d 7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle.vx[i]*dt;[14;5Hparticle.y[i]  += particle.vy[i]*dt;[15;5Hparticle.z[i]  += particle.vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12;23H[13d[A[A [10;23H[A[A[A  }[6;23H[A[A[5d[6d[7;4H[8d[9;23H[10d[11d [12;23H[13d[14d[15d[16;4H[17d[18d[19;23H[20d[21;23H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[nParticles];[21;3H// Initialize random number generator and particles[12;23H[13d[14d[15d[16;23H[17d[18d[19d[20d[21;23H7[3;22r8[22d[10S[1;24r[12;3HVSLStreamStatePtr rnStream;[13;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[14;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[15;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[17;3H// Perform benchmark[18;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[19;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[20;10HnParticles,[21d#ifndef __MIC__[12;23H[13d[14d[15d[16;3H[17;23H[18d[19d[20d[21;16H7[3;22r8[22d[10S[1;24r[12;10H"CPU"[13d#else[14d	 "MIC"[15d#endif[16d	 );[17;3Hdouble rate = 0, dRate = 0; // Benchmarking data[18;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[19;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[20;3Hfor (int step = 1; step <= nSteps; step++) {[12;15H[13;6H[12;15H[A_[10;21H[Ain[A[A[A  [5;23H[A[A[2;21r[2;1H[10T[1;24r[3;3Hconst int nSteps = 10;  // Duration of test[4;3Hconst float dt = 0.01f; // Particle propagation time step[6;3H// Particle data stored as an Array of Structures (AoS)[7;3H// this is good object-oriented programming style,[8;3H// but inefficient for the purposes of vectorization[9;3HParticleSet* particle = new ParticleSet[nParticles];[11;3H// Initialize random number generator and particles[12;3HVSLStreamStatePtr rnStream;[23G[A[A[9;23H[A[A[A[A[4;23H[A[2;21r[2;1H[10T[1;24r[3;5Hparticle.x[i]  += particle.vx[i]*dt;[4;5Hparticle.y[i]  += particle.vy[i]*dt;[5;5Hparticle.z[i]  += particle.vz[i]*dt;[6;3H}[7d}[9dint main(const int argc, const char** argv) {[11;3H// Problem size and other parameters[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[12;23H[A[A[9;23H[A[A}[A }[5;23H[A[A[2;21r[2;1H[10T[1;24r[3;5H// Accelerate particles in response to the gravitational force[4;5Hparticle[i].vx += dt*Fx;[5;5Hparticle[i].vy += dt*Fy;[6;5Hparticle[i].vz += dt*Fz;[7;3H}[9d// Move particles according to their velocities[10;3H// O(N) work, so using a serial loop[12;3Hfor (int i = 0 ; i < nParticles; i++) {[12;23H[A [10;23H[A[A[A  }[6;23H[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[4;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[6;7H// Calculate the net force[7;7HFx += dx * drPowerN32;[8;7HFy += dy * drPowerN32;[9;7HFz += dz * drPowerN32;[11;5H}[12d[11;6H[A[9;23H[A[A[A[5;9H[4;23H[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;23H[A[A[11d[12d[13d[14d[15;9H[16;23H[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;23H[A[11;6H[12d[13;23H[14d[A[A[11;6H[A[9;23H[A[A[A[5;9H[4;23H[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;23H[A[A[A[A[7;23H[A[5;7H[4;23H[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[6;1H#pragma omp parallel for schedule(guided)[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;7H[13;23H[14d[15;7H[16;23H[17d[18d[19;23H[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;23H[13d[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc[1P[1P[1P[1P[1P
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle.vx[i]*dt;[14;5Hparticle.y[i]  += particle.vy[i]*dt;[15;5Hparticle.z[i]  += particle.vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[13d[14d[A[A[A[A[A[A[A[A[A[A[5d[A    par	icle[i]	vx +=[5d[6d[7;4H[8d[9;22H[10d[11d [12;22H[13d[14d[15d[17d}[18d[19;22H[20d[21;22H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[nParticles];[21;3H// Initialize random number generator and particles[12;22H[13d[14d[15d[16;22H[17d[18d[19d[20d[19;22H[A[A[A[A[14;22H[A[A[A[A[9;22H[A[A}[A }[5;22H[A[A[2;21r[2;1H[10T[1;24r[3;5H// Accelerate particles in response to the gravitational force[4;5Hparticle[i].vx += dt*Fx;[5;5Hparticle[i].vy += dt*Fy;[6;5Hparticle[i].vz += dt*Fz;[7;3H}[9d// Move particles according to their velocities[10;3H// O(N) work, so using a serial loop[12;3Hfor (int i = 0 ; i < nParticles; i++) {[12;22H[A [10;22H[A[A[A  }[6;22H[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[4;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[6;7H// Calculate the net force[7;7HFx += dx * drPowerN32;[8;7HFy += dy * drPowerN32;[9;7HFz += dz * drPowerN32;[11;5H}[12d[11;6H[A[9;22H[A[A[A[7d[A[5;9H[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;22H[A[A[A[10d[11d[12d[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[5@sudo [C[C[C[C[C[C[C[C[C[C[C[C[C
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo nano nbody.cc[5P[C[C[C[C[C[C[C[C[C[C[C[C[C[5@sudo [C[C[C[C[C[C[C[C[C[C[C[C[C[6Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must have integral or enum type
      particle[i].vx += dt*Fx; 
                        ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
      ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
                        ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
      ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
                        ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
      ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpusudo nano nbody.cc[5P[C[C[C[C[C[C[C[C[C[C[C[C[C
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle.vx[i]*dt;[14;5Hparticle.y[i]  += particle.vy[i]*dt;[15;5Hparticle.z[i]  += particle.vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[13d[14d[A[A[A[A[A[A[A[A[A[A    par	icle[i]	vx[5d[6d[7;4H[8d[9;19H[10d[11d [12;19H[13d[14d[15d[16;4H[17d[18d[19;19H[20d[21;19H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[nParticles];[21;3H// Initialize random number generator and particles[12;19H[13d[14d[15d[16;19H[17d[18d[19d[20d[21;19H7[3;22r8[22d[10S[1;24r[12;3HVSLStreamStatePtr rnStream;[13;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[14;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[15;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[17;3H// Perform benchmark[18;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[19;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[20;10HnParticles,[21d#ifndef __MIC__[12;19H[13d[14d[15d[16;3H[17;19H[18d[19d[20d[21;16H7[3;22r8[22d[10S[1;24r[12;10H"CPU"[13d#else[14d	 "MIC"[15d#endif[16d	 );[17;3Hdouble rate = 0, dRate = 0; // Benchmarking data[18;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[19;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[20;3Hfor (int step = 1; step <= nSteps; step++) {[12;15H[13;6H[14;15H[15;7H[16;12H[17;19H[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hconst double tStart = omp_get_wtime(); // Start timing[13;5HMoveParticles(nParticles, particle, dt);[14;5Hconst double tEnd = omp_get_wtime(); // End timing[16;5Hconst float HztoInts   = float(nParticles)*float(nParticles-1) ;[17;5Hconst float HztoGFLOPs = 20.0*1e-9*float(nParticles)*float(nParticles-1);[19;5Hif (step > skipSteps) { // Collect statistics[20;7Hrate  += HztoGFLOPs/(tEnd - tStart);[21;7HdRate += HztoGFLOPs*HztoGFLOPs/((tEnd - tStart)*(tEnd-tStart));[12;19H[13d[14d[15d[16;19H[17d[18d[19;19H[20d[21d7[3;22r8[22d[10S[1;24r[12;5H}[14dprintf("%5d %10.3e %10.3e %8.1f %s\n",[15;12Hstep, (tEnd-tStart), HztoInts/(tEnd-tStart), HztoGFLOPs/(tEnd-tStart$[16;5Hfflush(stdout);[17;3H}[18drate/=(double)(nSteps-skipSteps);[19;3HdRate=sqrt(dRate/(double)(nSteps-skipSteps)-rate*rate);[20;3Hprintf("-----------------------------------------------------\n");[21;3Hprintf("\033[1m%s %4s \033[42m%10.1f +- %.1f GFLOP/s\033[0m\n",[12;6H[13d[14;19H[A[12;6H[11;19H[A[A[A[7;19H[A[A[4;19H[A[2;21r[2;1H[10T[1;24r[3;1H#else[4d	 "MIC"[5d#endif[6d	 );[7;3Hdouble rate = 0, dRate = 0; // Benchmarking data[8;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[9;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[10;3Hfor (int step = 1; step <= nSteps; step++) {[12;5Hconst double tStart = omp_get_wtime(); // Start timing[12;19H[A[10;19H[A[A[A[6;12H[5;7H[4;15H[3;6H[2;21r[2;1H[10T[1;24r[3;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[4;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[5;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[7;3H// Perform benchmark[8;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[9;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[10;10HnParticles,[11d#ifndef __MIC__[12;10H"CPU"[A_[A	le[A[A[A[A  [5;19H[A[A[2;21r[2;1H[10T[1;24r[3;3Hconst int nSteps = 10;  // Duration of test[4;3Hconst float dt = 0.01f; // Particle propagation time step[6;3H// Particle data stored as an Array of Structures (AoS)[7;3H// this is good object-oriented programming style,[8;3H// but inefficient for the purposes of vectorization[9;3HParticleSet* particle = new ParticleSet[nParticles];[11;3H// Initialize random number generator and particles[12;3HVSLStreamStatePtr rnStream;[12;19H[A[A[9;19H[A[A[A[A[4;19H[A[2;21r[2;1H[10T[1;24r[3;5Hparticle.x[i]  += particle.vx[i]*dt;[4;5Hparticle.y[i]  += particle.vy[i]*dt;[5;5Hparticle.z[i]  += particle.vz[i]*dt;[6;3H}[7d}[9dint main(const int argc, const char** argv) {[11;3H// Problem size and other parameters[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[12;19H[A[A[9;19H[A[A}[A }[5;19H[A[A[2;21r[2;1H[10T[1;24r[3;5H// Accelerate particles in response to the gravitational force[4;5Hparticle[i].vx += dt*Fx;[5;5Hparticle[i].vy += dt*Fy;[6;5Hparticle[i].vz += dt*Fz;[7;3H}[9d// Move particles according to their velocities[10;3H// O(N) work, so using a serial loop[12;3Hfor (int i = 0 ; i < nParticles; i++) {[12;19H[A [10;19H[A[A[A  }[8d[9;19H[10d[11d [12;19H[13d += [A[A [10;23H[A[A[A  }[6;23H[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[4;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[6;7H// Calculate the net force[7;7HFx += dx * drPowerN32;[8;7HFy += dy * drPowerN32;[9;7HFz += dz * drPowerN32;[11;5H}[12d[11;6H[A[9;23H[A[A[A[5;9H[4;23H[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;23H[A[A[A[A[7;23H[A[5;7H[4;23H[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[6;1H#pragma omp parallel for schedule(guided)[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;7H[11;23H[A[A[8;23H[A[A[A[A[A};[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz;[A[A{ [A[8;17H[Al.h>[A[A[Z[Ab>[A[2;21r[2;1H[10T[1;24r[3;1H/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[12d[11;23H[A[11d[12d[13d[14;19H[15;17H[16d>[17;21H[18;17H[19d[20;22H[21d7[2;22r8[22d[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;23H[13;3H[14d[15;23H[16d[17d[18d[19d[20;23H[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12;7H[13;23H[14d[15;7H[16;23H[17d[18d[19;23H[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;23H[13d[14d[15;9H[16;23H[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;23H[14d[1;71H(B[0;7mModified[14;23H(B[m(dt*Fx;[Z	t*Fx);[Z&(dt*Fx);[14;24H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must be an lvalue or a function designator
      particle[i].vx += &(dt*Fx); 
                         ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
      ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
                        ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
      ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
                        ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
      ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += &(dt*Fx);[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[16d[17d[18d[19d[A[A[A[A[A    par	icle[i]	vx += &	[1;71H(B[0;7mModified[14;24H(B[m[1P[1Pd	*Fx);[K[15d[16d[17;4H[18d[19;28H[20d[21d 7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle.vx[i]*dt;[14;5Hparticle.y[i]  += particle.vy[i]*dt;[15;5Hparticle.z[i]  += particle.vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12;28H[13d[14d[15d[16;4H[17d[18d[19;28H[A[A}[A }[14;28H[A[14d[A[Z[A[A [10;23H[A[A[A  }[6;23H[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[4;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[6;7H// Calculate the net force[7;7HFx += dx * drPowerN32;[8;7HFy += dy * drPowerN32;[9;7HFz += dz * drPowerN32;[11;5H}[12d[11;6H[A[9;23H[A[A[A[5;9H[4;23H[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;23H[A[A[A[A[7;23H[A[5;7H[4;23H[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[6;1H#pragma omp parallel for schedule(guided)[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;7H[11;23H[A[A[8;23H[A[A[A[A[A};[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz;[A[A{ [A[10;22H[11d[12;23H[13;3H[14d[15;23H[16d[17d[18d[19d[20;23H[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12;7H[13;23H[14d[15;7H[16;23H[17d[18d[19;23H[20d[21d[A[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 126 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must have integral or enum type
      particle[i].vx += dt*Fx; 
                        ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
      ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
                        ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
      ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
                        ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
      ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpu[Kmake run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 126 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[A[A[A[22d[K[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle.vx[i]*dt;[14;5Hparticle.y[i]  += particle.vy[i]*dt;[15;5Hparticle.z[i]  += particle.vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[nParticles];[21;3H// Initialize random number generator and particles[12d[13d[14d[15d[16d[17d[18d[19d  Parti	leSet* 	article	= new P	rticleS	t[nPart	cles];[1;71H(B[0;7mModified[19;52H(B[m];[K];[K];[K[Z];[K[Z];[K[Z];[K];[K];[K];[K];[K1];[A[A[A[A[14;44H[A[A[11;39H[A[9;44H[A[A}[A }[5;41H[A[A[2;21r[2;1H[10T[1;24r[3;5H// Accelerate particles in response to the gravitational force[4;5Hparticle[i].vx += dt*Fx;[5;5Hparticle[i].vy += dt*Fy;[6;5Hparticle[i].vz += dt*Fz;[7;3H}[9d// Move particles according to their velocities[10;3H// O(N) work, so using a serial loop[12;3Hfor (int i = 0 ; i < nParticles; i++) { [A [10;39H[A	elo[A[A  }[6;29H[A [A[3;44H[2;21r[2;1H[10T[1;24r[3;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[4;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[6;7H// Calculate the net force[7;7HFx += dx * drPowerN32;[8;7HFy += dy * drPowerN32;[9;7HFz += dz * drPowerN32;[11;5H}[12d[11;6H[A[9;29H[A  [A[A	[5;9H[4;44H[A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;44H[A[A[A[A[7;37H[6;44H[5;7H[4;44H[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[6;1H#pragma omp parallel for schedule(guided)[7;3H// Loop over particles that experience force[8;3Hfor (int i = 0; i < nParticles; i++) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;7H[11;35H[10;44H[A[8;42H[Afo[A[APa[A[A};[2;22r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz; [A[A{ [A[8;17H[Al.h>[A[A[Z[Ab>[A[2;21r[2;1H[10T[1;24r[3;1H/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[12d[11;44H[A[Z[11;44H[12d[13d[14;19H[15;17H[16d>[17;21H[18;17H[19d[20;22H[21d7[2;22r8[22d[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12;24H[13;3H[12;24H[Z[A[12d[13;3H[14d[15;11H[16d[17d[18d[19d[20;11H[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12;7H[13;11H[14d[15;7H[16;11H[17d[18d[19;11H[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;11H[13d[14d[15d	[16d C[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;11H[14d[15d[16d[17;4H[18d[19;11H[20d[21d 7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle.vx[i]*dt;[14;5Hparticle.y[i]  += particle.vy[i]*dt;[15;5Hparticle.z[i]  += particle.vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12;11H[13d[14d[15d[16;4H[17d[18d[19;11H[20d[21;11H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[1];[21;3H// Initialize random number generator and particles[12;11H[13d[14d[15d[16;11H[17d[18d[19d[20d[19;11H[20d[21;11H7[3;22r8[22d[10S[1;24r[12;3HVSLStreamStatePtr rnStream;[13;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[14;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[15;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[17;3H// Perform benchmark[18;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[19;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[20;10HnParticles,[21d#ifndef __MIC__[12;11H[13d[14d[15d[A[A[A[A[A  *vs x  [K  x[K  particle.x  .x&xx[K*xx[Kx[Kx[Kex-x>xx' ;7[11;21r8[11dM[1;24r[11;1H[11;9H[A[9;46H[10;15H=; ;;[K;[K ;=; ;[Zn;e;w; ;f;l;a;o;[Zt;(;[A[A[A[A[A[4;27H[A[2;21r[2;1H[10T[1;24r[3;5Hparticle.x[i]  += particle.vx[i]*dt;[4;5Hparticle.y[i]  += particle.vy[i]*dt;[5;5Hparticle.z[i]  += particle.vz[i]*dt;[6;3H}[7d}[9dint main(const int argc, const char** argv) {[11;3H// Problem size and other parameters[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[12;27H[A[A[9;27H[A[A}[8d[9;27H[10d[11;27H[12d[13d[14d[15d[16;27H[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3H// Initialize random number generator and particles[13;3HVSLStreamStatePtr rnStream;[14;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[15;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[16;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[18;3H// Perform benchmark[19;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[20;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[21;10HnParticles,[12;27H[A[10;27Hn;p;;[K;[K;[K[;;[K[;n;p;a;r;t;i;[Zc;l;e;s;];[Z[A[A[A[A[A[4;31H[A[2;21r[2;1H[10T[1;24r[3;5Hparticle.x[i]  += particle.vx[i]*dt;[4;5Hparticle.y[i]  += particle.vy[i]*dt;[5;5Hparticle.z[i]  += particle.vz[i]*dt;[6;3H}[7d}[9dint main(const int argc, const char** argv) {[11;3H// Problem size and other parameters[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[12;31H[A[12d[13d[14d[15d[16;31H[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3H// Initialize random number generator and particles[13;3HVSLStreamStatePtr rnStream;[14;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[15;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[16;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[18;3H// Perform benchmark[19;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[20;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[21;10HnParticles,[12;31H[A[10;31H[1PParticles];[10;29Hart	cles];7[11;21r8[11dM[1;24r[11;1H P[K   p[K  particles -? >y =	new floa  [Aa	[1P[1Pat[nParticles];[10;24Hot[nParticles];[10;25H[1P[1Pot[nParticles];[10;24Hat[nParticles];[10;25H[11doat[nParticles];7[12;21r8[12dM[1;24r[12;1H  particle-? >z =	new float[npa  [P  p Particles]l ;7[13;21r8[13dM[1;24r[13;1H  particle-? >[A[A[A[A[A[A[A[A[4;13H[A[2;21r[2;1H[10T[1;24r[3;5Hparticle.x[i]  += particle.vx[i]*dt;[4;5Hparticle.y[i]  += particle.vy[i]*dt;[5;5Hparticle.z[i]  += particle.vz[i]*dt;[6;3H}[7d}[9dint main(const int argc, const char** argv) {[11;3H// Problem size and other parameters[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[12;13H[A[A[9;13H[A[A}[A }[5;13H[A[A[2;21r[2;1H[10T[1;24r[3;5H// Accelerate particles in response to the gravitational force[4;5Hparticle[i].vx += dt*Fx;[5;5Hparticle[i].vy += dt*Fy;[6;5Hparticle[i].vz += dt*Fz;[7;3H}[9d// Move particles according to their velocities[10;3H// O(N) work, so using a serial loop[12;3Hfor (int i = 0 ; i < nParticles; i++) {[12;13H[A [10;13H[A[A[A  }[6;13H[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[4;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[6;7H// Calculate the net force[7;7HFx += dx * drPowerN32;[8;7HFy += dy * drPowerN32;[9;7HFz += dz * drPowerN32;[11;5H}[12d[11;6H[A[9;13H[A[A[A[A	[Anst [A[2;22r[2;1H[10T[1;24r[3;5H// Loop over particles that exert force: vectorization expected here[4;5Hfor (int j = 0; j < nParticles; j++) {[6;7H// Avoid singularity and interaction with self[7;7Hconst float softening = 1e-20;[9;7H// Newton's law of universal gravity[10;7Hconst float dx = particle.x[j] - particle.x[i];[11;7Hconst float dy = particle.y[j] - particle.y[i];[12;7Hconst float dz = particle.z[j] - particle.z[i];[12;13H[A[A[A[A[7;13H[A[5;7H[6;13H[7d[8d[9;13H[10d[11d[12d[13d[14d[15d	[16;13H[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;13H[14d[15d[16d[17;4H[18d[19;13H[20d[21d 7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle.vx[i]*dt;[14;5Hparticle.y[i]  += particle.vy[i]*dt;[15;5Hparticle.z[i]  += particle.vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12;13H[13d[14d[15d[16;4H[17d[18d[19;13H[20d[21;13H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[1];[20;3Hparticle->x = new float[nParticles];[21;3Hparticle->y = new float[nParticles];[12;13H[13d[14d[15d[16;13H[17d[18d[20d[21d7[3;22r8[22d[10S[1;24r[12;3Hparticle->z = new float[nParticles];[13;3Hparticle->[15;3H// Initialize random number generator and particles[16;3HVSLStreamStatePtr rnStream;[17;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[18;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[19;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[21;3H// Perform benchmark[12;13H[13dvx   x = new f; loat[nParticles]l ;7[14;21r8[14dM[1;24r[14;1H  particle->vy = new float[npa  Particles];7[15;22r8[15dM[1;24r[15;1H  particle->vz = new float[nParticles];[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 132 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                         ^

nbody.cc(38): error: expression must have class type
        const float dx = particle.x[j] - particle.x[i];
                                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                         ^

nbody.cc(39): error: expression must have class type
        const float dy = particle.y[j] - particle.y[i];
                                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                         ^

nbody.cc(40): error: expression must have class type
        const float dz = particle.z[j] - particle.z[i];
                                         ^

nbody.cc(52): error: expression must have integral or enum type
      particle[i].vx += dt*Fx; 
                        ^

nbody.cc(53): error: expression must have integral or enum type
      particle[i].vy += dt*Fy; 
                        ^

nbody.cc(54): error: expression must have integral or enum type
      particle[i].vz += dt*Fz;
                        ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
      ^

nbody.cc(61): error: expression must have class type
      particle.x[i]  += particle.vx[i]*dt;
                        ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
      ^

nbody.cc(62): error: expression must have class type
      particle.y[i]  += particle.vy[i]*dt;
                        ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
      ^

nbody.cc(63): error: expression must have class type
      particle.z[i]  += particle.vz[i]*dt;
                        ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 132 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle.x[j] - particle.x[i];[21;7Hconst float dy = particle.y[j] - particle.y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d[A      c	[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle.z[j] - particle.z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12;9H[A[Anst flo	t dx = 	article	x[Z	[1;71H(B[0;7mModified[10;32H(B[m[1P-x[j] - particle.x[i];[10;33H?x[j] - particle.x[i];[10;34H[Z[1P>x[j] - particle.x[i];[10;34Hx[j] -	particl	.[Zx[i];[K[Z-x[i];[50G>x[i];[51G[11d[Zy[i];[K[Z-y[i];[Z>y[i];[50G[Z[Z[Z[1P-y[j] - particle->y[i];[11;33H>y[j] - particle->y[i];[11;34H[12d[Z[1P-z[j] - particle.z[i];[12;33H>z[j] - particle.z[i];[12;34Hz[j] -	particl	.[Zz[i];[K[Z-z[i];[50G>z[i];[51G[13d[14d[15;9H[16;33H[17d[18d[19d[20d[21;6H7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i].vx += dt*Fx;[15;5Hparticle[i].vy += dt*Fy;[16;5Hparticle[i].vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13;51H[14;30H[15d[A[Z[15d[16d[17;4H[18d[19;23H[20d[21d 7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle.x[i]  += particle.vx[i]*dt;[14;5Hparticle.y[i]  += particle.vy[i]*dt;[15;5Hparticle.z[i]  += particle.vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12;23H[13dp	rticle.[1P-vx[i]*dt;[13;32H>vx[i]*dt;[13;33H[14d[1P-vy[i]*dt;[14;32H>vy[i]*dt;[14;33H[15d[1P-vz[i]*dt;[15;32H>vz[i]*dt;[15;33H[Z[Z[1P-z[i]  += particle->vz[i]*dt;[15;14H>z[i]  += particle->vz[i]*dt;[15;15H[A[1P-y[i]  += particle->vy[i]*dt;[14;14H>y[i]  += particle->vy[i]*dt;[14;15H[A[1P-x[i]  += particle->vx[i]*dt;[13;14H>x[i]  += particle->vx[i]*dt;[13;15H[14d[15d[A[A[A[A [10;15H[A[A[A  }[6;15H]	[1P-vz += dt*Fz;[6;17H>vz += dt*Fz;[6;18H[A[Z[1P-vy += dt*Fy;[5;17H>vy += dt*Fy;[5;18H[A[Z[1P0-vx += dt*Fx;[4;18H[Z[1P[1P-vx += dt*Fx;[4;17H>vx += dt*Fx;[4;18H[5d[6d[7;4H[8d[9;18H[10d[11d [12;18H[13d[14d[15d[16;4H[17d[18d[19;18H[20d[21;18H7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[1];[20;3Hparticle->x = new float[nParticles];[21;3Hparticle->y = new float[nParticles];[12;18H[13d[14d[15d[16;18H[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3Hparticle->z = new float[nParticles];[13;3Hparticle->vx = new float[nParticles];[14;3Hparticle->vy = new float[nParticles];[15;3Hparticle->vz = new float[nParticles];[17;3H// Initialize random number generator and particles[18;3HVSLStreamStatePtr rnStream;[19;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[20;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[21;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[12;18H[13d[14d[15d[16d[17;18H[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13d  // Perform benchmark[14;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[15;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[16;10HnParticles,[17d#ifndef __MIC__[18;10H"CPU"[19d#else[20d	 "MIC"[21d#endif[12;3H[13;18H[14d[15d[16d[17;16H[18d[19;6H[20;15H[21;7H7[2;22r8[22d[10S[1;24r[12;10H);[13;3Hdouble rate = 0, dRate = 0; // Benchmarking data[14;3Hconst int skipSteps = 3; // Skip first iteration is warm-up on Xeon Phi copro$[15;3Hprintf("\033[1m%5s %10s %10s %8s\033[0m\n", "Step", "Time, s", "Interact/s", $[16;3Hfor (int step = 1; step <= nSteps; step++) {[18;5Hconst double tStart = omp_get_wtime(); // Start timing[19;5HMoveParticles(nParticles, particle, dt);[20;5Hconst double tEnd = omp_get_wtime(); // End timing[12;12H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 132 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(52): error: expression must have pointer type
      particle[i]->vx += dt*Fx; 
      ^

nbody.cc(53): error: expression must have pointer type
      particle[i]->vy += dt*Fy; 
      ^

nbody.cc(54): error: expression must have pointer type
      particle[i]->vz += dt*Fz;
      ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 132 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle->x[j] - particle->x[i];[21;7Hconst float dy = particle->y[j] - particle->y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle->z[j] - particle->z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[15d[A[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle[i]->vx += dt*Fx;[15;5Hparticle[i]->vy += dt*Fy;[16;5Hparticle[i]->vz += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[16d[17d  }[18d[19d  //[A[A  }[A [A[Apar	icle[i]	>v[Z>[1;71H(B[0;7mModified[14;17H(B[m[1P[1P[1P[1P[1P-vx += dt*Fx;[14;14H>vx += dt*Fx;[14;15Hv	[ += dt*Fx;[14;18Hi += dt*Fx;[14;19H] += dt*Fx;[14;20H[Z[15d	[1P[1P[1P->v	[ += dt*Fy;[15;18Hi += dt*Fy;[15;19H] += dt*Fy;[15;20H[16d[Z[1P[1P[1P->v	[ += dt*Fz;[16;18Hi += dt*Fz;[16;19H] += dt*Fz;[16;20H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 132 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536
make: *** [run-cpu] Segmentation fault (core dumped)
rm nbody.o
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 132 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle->x[j] - particle->x[i];[21;7Hconst float dy = particle->y[j] - particle->y[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;7Hconst float dz = particle->z[j] - particle->z[i];[13;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[14;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[16;7H// Calculate the net force[17;7HFx += dx * drPowerN32;[18;7HFy += dy * drPowerN32;[19;7HFz += dz * drPowerN32;[21;5H}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Accelerate particles in response to the gravitational force[14;5Hparticle->vx[i] += dt*Fx;[15;5Hparticle->vy[i] += dt*Fy;[16;5Hparticle->vz[i] += dt*Fz;[17;3H}[19d// Move particles according to their velocities[20;3H// O(N) work, so using a serial loop[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3Hfor (int i = 0 ; i < nParticles; i++) {[13;5Hparticle->x[i]  += particle->vx[i]*dt;[14;5Hparticle->y[i]  += particle->vy[i]*dt;[15;5Hparticle->z[i]  += particle->vz[i]*dt;[16;3H}[17d}[19dint main(const int argc, const char** argv) {[21;3H// Problem size and other parameters[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3Hconst int nParticles = (argc > 1 ? atoi(argv[1]) : 16384);[13;3Hconst int nSteps = 10;  // Duration of test[14;3Hconst float dt = 0.01f; // Particle propagation time step[16;3H// Particle data stored as an Array of Structures (AoS)[17;3H// this is good object-oriented programming style,[18;3H// but inefficient for the purposes of vectorization[19;3HParticleSet* particle = new ParticleSet[1];[20;3Hparticle->x = new float[nParticles];[21;3Hparticle->y = new float[nParticles];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;3Hparticle->z = new float[nParticles];[13;3Hparticle->vx = new float[nParticles];[14;3Hparticle->vy = new float[nParticles];[15;3Hparticle->vz = new float[nParticles];[17;3H// Initialize random number generator and particles[18;3HVSLStreamStatePtr rnStream;[19;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, 1 );[20;3HvsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[21;16HrnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[12d[13d[14d[15d[16d[17d[18d[19d[20d [A[1;71H(B[0;7mModified[19;2H(B[m/ vslNewStream( &rnStream, VSL_BRNG_MT19937, 1 ); /// vslNewStream( &rnStream, VSL_BRNG_MT19937, 1 ); //[1P/[1P[20d /vsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,  ///vsRngUniform(VSL_RNG_METHOD_UNIFORM_STD,[5G[21d[21;9H      / rnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[21;16H// rnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[21;17H[1P7[2;22r8[22d[10S[1;24r[2;1H[K[13d  // Perform benchmark[14;3Hprintf("\n\033[1mNBODY Version 00\033[0m\n");[15;3Hprintf("\nPropagating %d particles using 1 thread on %s...\n\n",[16;10HnParticles,[17d#ifndef __MIC__[18;10H"CPU"[19d#else[20d	 "MIC"[21d#endif[12;3H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 132 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  2.801e-01  1.533e+10    306.7 *
    2  4.780e-02  8.985e+10   1797.0 *
    3  4.744e-02  9.053e+10   1810.6 *
    4  4.744e-02  9.054e+10   1810.9 
    5  4.746e-02  9.049e+10   1809.8 
    6  4.761e-02  9.022e+10   1804.4 
    7  4.749e-02  9.043e+10   1808.6 
    8  4.756e-02  9.031e+10   1806.3 
    9  4.747e-02  9.048e+10   1809.5 
   10  4.743e-02  9.055e+10   1811.0 
-----------------------------------------------------
[1mAverage performance:      [42m    1808.6 +- 2.3 GFLOP/s[0m
-----------------------------------------------------
* - warm-up, not included in average

rm nbody.o
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ ls
[0m[01;32mapp-CPU[0m           [01;32mnbody.cc[0m        ScalarTuning.txt
[01;32minstructions.txt[0m  nbody.o.optrpt  ThreadParallelism.txt
[01;32mMakefile[0m          original.txt    Vectorization.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ sudo [K[K[K[K[Ksudo rm Vectorization.txt 
[sudo] password for test10: 
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ ls
[0m[01;32mapp-CPU[0m           [01;32mMakefile[0m  nbody.o.optrpt  ScalarTuning.txt
[01;32minstructions.txt[0m  [01;32mnbody.cc[0m  original.txt    ThreadParallelism.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ scro[Kipt Vectorization.txt
Script started, file is Vectorization.txt
Intel(R) Parallel Studio XE 2017 for Linux*
Copyright (C) 2009-2016 Intel Corporation. All rights reserved.
]0;test10@localhost:~/kmin/nbody[?1034h[test10@localhost nbody]$ c[Kmake run-cpu[1Pvi nbody.ccmake run-cpu
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  3.946e-01  1.088e+10    217.7 *
    2  5.081e-02  8.453e+10   1690.6 *
    3  4.887e-02  8.789e+10   1757.9 *
    4  5.094e-02  8.432e+10   1686.4 
    5  5.074e-02  8.464e+10   1692.9 
    6  5.225e-02  8.220e+10   1644.0 
    7  5.610e-02  7.656e+10   1531.2 
    8  4.959e-02  8.660e+10   1732.1 
    9  6.507e-02  6.600e+10   1320.0 
   10  5.425e-02  7.916e+10   1583.3 
-----------------------------------------------------
[1mAverage performance:      [42m    1598.6 +- 130.3 GFLOP/s[0m
-----------------------------------------------------
* - warm-up, not included in average

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ exit
Script done, file is Vectorization.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ script Vectorization.txtls[Ksudo rm Vectorization.txt ls[Kmake run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 132 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int i = 0; i < nParticles; i++) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx = 0, Fy = 0, Fz = 0;[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[A[A  for (	nt i = 	; i < n	arti[19d[20;29H[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H// Loop over particles that exert force: vectorization expected here[14;5Hfor (int j = 0; j < nParticles; j++) {[16;7H// Avoid singularity and interaction with self[17;7Hconst float softening = 1e-20;[19;7H// Newton's law of universal gravity[20;7Hconst float dx = particle->x[j] - particle->x[i];[21;7Hconst float dy = particle->y[j] - particle->y[i];[12;7H[13;29H[14d[15;7H[16;29H[17d[A[15;7H[14;29H[A[12;7H[11;29H[A[A[8;29H[Z[Z[1;71H(B[0;7mModified[8;12H(B[mii = 0; i < nParticles; i++) {[8;13Hi =	0; ii < nParticles; i++) {[8;21Hi <	nPartic	es; i+++) {[K[39G) {[Kii) {[39G+) {[Z=) {[Zt) {i) {l) {e) {S) {i) {[47Gz) {[Ze) {[Z[9d[10;49H[11;35H[Z[Z[Z[1P[1P[1P[1P[, Fy = 0, Fz = 0;[11;14Ht, Fy = 0, Fz = 0;[11;15Hi, Fy = 0, Fz = 0;[11;16Hl, Fy = 0, Fz = 0;[11;17He, Fy = 0, Fz = 0;[11;18HS, Fy = 0, Fz = 0;[11;19Hi, Fy = 0, Fz = 0;[11;20Hz, Fy = 0, Fz = 0;[11;21He, Fy = 0, Fz = 0;[11;22H], Fy = 0, Fz = 0;[11;23H,	Fy = 0[1P[1P[1P[1P[, Fz = 0;[11;28Ht, Fz = 0;[11;29Hi, Fz = 0;[11;30Hl, Fz = 0;[11;31He, Fz = 0;[11;32HS, Fz = 0;[11;33Hi, Fz = 0;[11;34Hz, Fz = 0;[11;35He, Fz = 0;[11;36H], Fz = 0;[11;37H, F	 = 0;[K;[K;[K[Z;[K[Z[;t;i;l;e;S;i;l;[Zz;[Z;[K[Z;[Kz;[Ze;];7[12;21r8[12dM[1;24r[11;51H [12d;[12;22r[22;1H
[1;24r[11;51H;[21;7Hconst float dy = particle->y[j] - particle->y[i];[11;51H;7[12;21r8[12dM[1;24r[12;1H[12;9HFx[:] =	Fy] [:] =	Fy =  ] [:\ ] =	0;7[13;21r8[13dM[1;24r[13;1H[14d[13;22r[22;1H
[1;24r[21;7Hconst float dx = particle->x[j] - particle->x[i];[13d #pragma	unroll(tileSize)[14d[15dnP[16;7H[17;27H[18d[19d[20;27H[21d7[3;22r8[22d[10S[1;24r[12;7Hconst float dy = particle->y[j] - particle->y[i];[13;7Hconst float dz = particle->z[j] - particle->z[i];[14;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[15;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[17;7H// Calculate the net force[18;7HFx += dx * drPowerN32;[19;7HFy += dy * drPowerN32;[20;7HFz += dz * drPowerN32;[12;27H[13d[14d[15d[16;9H[15;57H[16dfor(int	i = 	 	      [K[A[A[A[A[A[A[A[A[A[A11 [K[6;9H[6;17H[6;9Hfor ) (int i = ii; i< ii    < ii	+ tileSize; i++_ ){[7d[8;37H[9d[10;43H[A[8;37H[7;50H[A[7d[8;37H[7;50H[A[7d[8;37H[9d[10;43H[11;50H[12d[13d[14d[15d[16;9H[17;33H[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[12;5H}[14d// Accelerate particles in response to the gravitational force[15;5Hparticle->vx[i] += dt*Fx;[16;5Hparticle->vy[i] += dt*Fy;[17;5Hparticle->vz[i] += dt*Fz;[18;3H}[20d// Move particles according to their velocities[21;3H// O(N) work, so using a serial loop[12;6H[A}[A[A     [A[A[8dF	[ += dx * drPowerN32;[8;10Hi += dx * drPowerN32;[8;11H- += dx * drPowerN32;[8;12Hi += dx * drPowerN32;[8;13Hii += dx * drPowerN32;[8;14H] += dx * drPowerN32;[8;15H 	= d[9d[Z	[ += dy * drPowerN32;[9;10Hi += dy * drPowerN32;[9;11H- += dy * drPowerN32;[9;12Hi += dy * drPowerN32;[9;13Hii += dy * drPowerN32;[9;14H] += dy * drPowerN32;[9;15H[10d	[ += dz * drPowerN32;[10;10Hi += dz * drPowerN32;[10;11H= += dz * drPowerN32;[10;12H[1P- += dz * drPowerN32;[10;12Hi += dz * drPowerN32;[10;13Hii += dz * drPowerN32;[10;14H] += dz * drPowerN32;[10;15H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 133 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.ccscript Vectorization.txtls[Ksudo rm Vectorization.txt ls[Kmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(26): error: identifier "tileSize" is undefined
    for (int ii = 0; ii < nParticles; ii+=tileSize) { 
                                          ^

nbody.cc(31): warning #28: expression must have a constant value
  #pragma unroll(tileSize)      
                 ^

nbody.cc(53): error: identifier "i" is undefined
      particle->vx[i] += dt*Fx; 
                   ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 133 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;9HFx[:] = Fy[:] = Fy[:] = 0;[13d#pragma unroll(tileSize)[14;5H// Loop over particles that exert force: vectorization expected here[15;5Hfor (int j = 0; j < nParticles; j++) {[16;9Hfor (int i = ii; i < ii + tileSize; i++){[17;7H// Avoid singularity and interaction with self[18;7Hconst float softening = 1e-20;[20;7H// Newton's law of universal gravity[21;7Hconst float dx = particle->x[j] - particle->x[i];[12d[13d[14d[15d[3;22r[22;1H[10S[1;24r[12;7Hconst float dy = particle->y[j] - particle->y[i];[13;7Hconst float dz = particle->z[j] - particle->z[i];[14;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[15;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[17;7H// Calculate the net force[18;7HFx[i-ii] += dx * drPowerN32;[19;7HFy[i-ii] += dy * drPowerN32;[20;7HFz[i-ii] += dz * drPowerN32;[21d}[15d[16d[A[A[A[A[A[A[A[A  [A[A[6;9Hf[7d[8d[9d[10;10H[11d[12d[13d[14d[15d[16d	[17d [18d[19d[20d[21d}7[2;22r8[22d[10S[1;24r[2;1H[K[12;5H}[14d// Accelerate particles in response to the gravitational force[15;5Hparticle->vx[i] += dt*Fx;[16;5Hparticle->vy[i] += dt*Fy;[17;5Hparticle->vz[i] += dt*Fz;[18;3H}[20d// Move particles according to their velocities[21;3H// O(N) work, so using a serial loop[12;6H[13d[14;10H[15d[16d[Acle->v	[[A[A[10;18H[A[10d[11d}[1;71H(B[0;7mModified[11d(B[m[K[12d[13d[14d[15d[16d[17d[18d[19d}[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 133 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(26): error: identifier "tileSize" is undefined
    for (int ii = 0; ii < nParticles; ii+=tileSize) { 
                                          ^

nbody.cc(31): warning #28: expression must have a constant value
  #pragma unroll(tileSize)      
                 ^

nbody.cc(53): error: identifier "i" is undefined
      particle->vx[i] += dt*Fx; 
                   ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[20dstruct ParticleSet {[21;3Hfloat *x, *y, *z;[22;32H(B[0;7m[ Read 133 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *vx, *vy, *vz;[13d};[15dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[16;1H#pragma omp parallel for schedule(guided)[17;3H// Loop over particles that experience force[18;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[20;5H// Components of the gravity force on particle i[21;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;9HFx[:] = Fy[:] = Fy[:] = 0;[13d#pragma unroll(tileSize)[14;5H// Loop over particles that exert force: vectorization expected here[15;5Hfor (int j = 0; j < nParticles; j++) {[16;9Hfor (int i = ii; i < ii + tileSize; i++){[17;7H// Avoid singularity and interaction with self[18;7Hconst float softening = 1e-20;[20;7H// Newton's law of universal gravity[21;7Hconst float dx = particle->x[j] - particle->x[i];[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;7Hconst float dy = particle->y[j] - particle->y[i];[13;7Hconst float dz = particle->z[j] - particle->z[i];[14;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[15;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[17;7H// Calculate the net force[18;7HFx[i-ii] += dx * drPowerN32;[19;7HFy[i-ii] += dy * drPowerN32;[20;7HFz[i-ii] += dz * drPowerN32;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[A[4d[5d[6d[A[A[A[2;21r[2;1H[10T[1;24r[3;1H};[5dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[6;1H#pragma omp parallel for schedule(guided)[7;3H// Loop over particles that experience force[8;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[10;5H// Components of the gravity force on particle i[11;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[12;9HFx[:] = Fy[:] = Fy[:] = 0;[A[12d[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[10dstruct ParticleSet {[11;3Hfloat *x, *y, *z;[12;3Hfloat *vx, *vy, *vz;[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;1H/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[12d[A[A[A[A[A[A[A[A[A[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[1;71H(B[0;7mModified[19d(B[m#d DEFINE	TI 	 	tileSzi  ize 16[20d[K[21dstruct ParticleSet {[A[21d7[2;22r8[22d[10S[1;24r[12;3Hfloat *x, *y, *z;[13;3Hfloat *vx, *vy, *vz;[14d};[16dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[17;1H#pragma omp parallel for schedule(guided)[18;3H// Loop over particles that experience force[19;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[21;5H// Components of the gravity force on particle i[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i];[13;7Hconst float dy = particle->y[j] - particle->y[i];[14;7Hconst float dz = particle->z[j] - particle->z[i];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12d[13d[14d[A[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 134 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(17): error #11: unrecognized preprocessing directive
  #DEFINE tileSize 16
   ^

nbody.cc(27): error: identifier "tileSize" is undefined
    for (int ii = 0; ii < nParticles; ii+=tileSize) { 
                                          ^

nbody.cc(32): warning #28: expression must have a constant value
  #pragma unroll(tileSize)      
                 ^

nbody.cc(54): error: identifier "i" is undefined
      particle->vx[i] += dt*Fx; 
                   ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[19d#DEFINE tileSize 16[21dstruct ParticleSet {[22;32H(B[0;7m[ Read 134 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d#DEFINE[1;71H(B[0;7mModified[19;7H(B[m[1P[1P[1P[22d[K[19;5H[1P[1P[1Pd tileSize 16#de tileSize 16#def tileSize 16[5Gi tileSize 16[6Gn tileSize 16[7Ge tileSize 16[8G[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 134 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(54): error: identifier "i" is undefined
      particle->vx[i] += dt*Fx; 
                   ^

nbody.cc(54): error: expression must have arithmetic or enum type
      particle->vx[i] += dt*Fx; 
                            ^

nbody.cc(55): error: expression must have arithmetic or enum type
      particle->vy[i] += dt*Fy; 
                            ^

nbody.cc(56): error: expression must have arithmetic or enum type
      particle->vz[i] += dt*Fz;
                            ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[19d#define tileSize 16[21dstruct ParticleSet {[22;32H(B[0;7m[ Read 134 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *x, *y, *z;[13;3Hfloat *vx, *vy, *vz;[14d};[16dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[17;1H#pragma omp parallel for schedule(guided)[18;3H// Loop over particles that experience force[19;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[21;5H// Components of the gravity force on particle i[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i];[13;7Hconst float dy = particle->y[j] - particle->y[i];[14;7Hconst float dz = particle->z[j] - particle->z[i];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H}[15d// Accelerate particles in response to the gravitational force[16;5Hparticle->vx[i] += dt*Fx;[17;5Hparticle->vy[i] += dt*Fy;[18;5Hparticle->vz[i] += dt*Fz;[19;3H}[20d}[21d // Move particles according to their velocities[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3H// O(N) work, so using a serial loop[14;3Hfor (int i = 0 ; i < nParticles; i++) {[15;5Hparticle->x[i]  += particle->vx[i]*dt;[16;5Hparticle->y[i]  += particle->vy[i]*dt;[17;5Hparticle->z[i]  += particle->vz[i]*dt;[18;3H}[19d}[21dint main(const int argc, const char** argv) {[12d[13d[14d[A[A[A[A[A[A[A[A    par	icle->v	[i] += 	t*Fx;7[7;21r8[7dM[1;24r[1;71H(B[0;7mModified[6;29H(B[m [7d;[7;22r[22;1H
[1;24r[6;29H;[21dint main(const int argc, const char** argv) {[6;29H[;:;];[7d[;:;];[8dz[;:;];[9;4H[10d[11;32H[12d[13d [14;32H[15d[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 134 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(54): error: identifier "i" is undefined
      particle->vx[i] += dt*Fx[:]; 
                   ^

nbody.cc(54): error: rank mismatch in array section expression
      particle->vx[i] += dt*Fx[:]; 
                      ^

nbody.cc(55): error: rank mismatch in array section expression
      particle->vy[i] += dt*Fy[:]; 
                      ^

nbody.cc(56): error: rank mismatch in array section expression
      particle->vz[i] += dt*Fz[:];
                      ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[19d#define tileSize 16[21dstruct ParticleSet {[22;32H(B[0;7m[ Read 134 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *x, *y, *z;[13;3Hfloat *vx, *vy, *vz;[14d};[16dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[17;1H#pragma omp parallel for schedule(guided)[18;3H// Loop over particles that experience force[19;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[21;5H// Components of the gravity force on particle i[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i];[13;7Hconst float dy = particle->y[j] - particle->y[i];[14;7Hconst float dz = particle->z[j] - particle->z[i];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H}[15d// Accelerate particles in response to the gravitational force[16;5Hparticle->vx[i] += dt*Fx[:];[17;5Hparticle->vy[i] += dt*Fy[:];[18;5Hparticle->vz[i] += dt*Fz[:];[19;3H}[20d}[21d // Move particles according to their velocities[12d[13d[14d[15d[16d[17d[18d    par	icle->v	[i] += 	t*Fz[:]	[19d [A   par	icle->v	[i] += 	t*Fz[:]	[A[A[1;71H(B[0;7mModified[16;30H(B[m];[Kt];i];[Zl];[Zs];[Z];[K[Z];[K[Zl];[Ze];S];i];z];e];[17;34H[Z];[Kt];i];[Zl];[Ze];S];i];z];e];[18;33H[A[Ai	eSize];[K];[K];[K];[K[Z];[K[Z];[K[Z];[K];[Ki];-];[Zi];[Zii];[17dSize];[K];[K];[K];[K[Z];[K[Z];[K[Z];[K];[Ki];-];[Zi];[Zii];[18;33H];[Ki];-];[Zi];[Zii];[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 134 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(54): error: identifier "i" is undefined
      particle->vx[i] += dt*Fx[i-ii]; 
                   ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[19d#define tileSize 16[21dstruct ParticleSet {[22;32H(B[0;7m[ Read 134 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *x, *y, *z;[13;3Hfloat *vx, *vy, *vz;[14d};[16dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[17;1H#pragma omp parallel for schedule(guided)[18;3H// Loop over particles that experience force[19;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[21;5H// Components of the gravity force on particle i[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i];[13;7Hconst float dy = particle->y[j] - particle->y[i];[14;7Hconst float dz = particle->z[j] - particle->z[i];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H}[15d// Accelerate particles in response to the gravitational force[16;5Hparticle->vx[i] += dt*Fx[i-ii];[17;5Hparticle->vy[i] += dt*Fy[i-ii];[18;5Hparticle->vz[i] += dt*Fz[i-ii];[19;3H}[20d}[21d // Move particles according to their velocities[12d[13d[14d[15d[16d    par	icle->v	[i[1;71H(B[0;7mModified[16;19H(B[m-] += dt*Fx[i-ii];[16;20Hi] += dt*Fx[i-ii];[16;21Hii] += dt*Fx[i-ii];[16;22H[17d-] += dt*Fy[i-ii];[17;20Hi] += dt*Fy[i-ii];[17;21Hii] += dt*Fy[i-ii];[17;22H[18d-] += dt*Fz[i-ii];[18;20Hi] += dt*Fz[i-ii];[18;21Hii] += dt*Fz[i-ii];[18;22H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 134 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"
nbody.cc(54): error: identifier "i" is undefined
      particle->vx[i-ii] += dt*Fx[i-ii]; 
                   ^

compilation aborted for nbody.cc (code 2)
make: *** [nbody.o] Error 2
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[19d#define tileSize 16[21dstruct ParticleSet {[22;32H(B[0;7m[ Read 134 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *x, *y, *z;[13;3Hfloat *vx, *vy, *vz;[14d};[16dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[17;1H#pragma omp parallel for schedule(guided)[18;3H// Loop over particles that experience force[19;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[21;5H// Components of the gravity force on particle i[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i];[13;7Hconst float dy = particle->y[j] - particle->y[i];[14;7Hconst float dz = particle->z[j] - particle->z[i];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H}[15d// Accelerate particles in response to the gravitational force[16;5Hparticle->vx[i-ii] += dt*Fx[i-ii];[17;5Hparticle->vy[i-ii] += dt*Fy[i-ii];[18;5Hparticle->vz[i-ii] += dt*Fz[i-ii];[19;3H}[20d}[21d // Move particles according to their velocities[12d[13d[14d[15d[16d[17d[A[A[A[15d [16d   par	icle->v	[i[1;71H(B[0;7mModified[16;18H(B[m[1P[1P[17di-[1P[1P[18di-[1P[1P[A[Aii] +=	dt*Fx[ii	ii];[K[Zii];[K[31G[17di	ii];[K[Zii];[K[31G[18di	ii];[K[Zii];[K[31G[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 134 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
make: *** [run-cpu] Segmentation fault (core dumped)
rm nbody.o
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[19d#define tileSize 16[21dstruct ParticleSet {[22;32H(B[0;7m[ Read 134 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *x, *y, *z;[13;3Hfloat *vx, *vy, *vz;[14d};[16dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[17;1H#pragma omp parallel for schedule(guided)[18;3H// Loop over particles that experience force[19;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[21;5H// Components of the gravity force on particle i[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12d[13d[14d[15d    /[17d[16;7H[A[A[A[14;7H[15d[16dr	(int j[17dn	 i[18dg[A= ii	 i < ii	+ ti[18d[19d[20d[21;37H7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i];[13;7Hconst float dy = particle->y[j] - particle->y[i];[14;7Hconst float dz = particle->z[j] - particle->z[i];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12;37H[13d[14d[15d[16d[17;9H[18;33H[19;37H[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H}[15d// Accelerate particles in response to the gravitational force[16;5Hparticle->vx[ii] += dt*Fx[ii];[17;5Hparticle->vy[ii] += dt*Fy[ii];[18;5Hparticle->vz[ii] += dt*Fz[ii];[19;3H}[20d}[21d // Move particles according to their velocities[12d[13;6H[14d[15;37H[16d[17d[18d[19;4H[18;35H[A [A[Z[A[A[13;6H[A[11;33H[A[A[A[7;9H[6;33H[A[A[A[2;22r[2;1H[10T[1;24r[3;9HFx[:] = Fy[:] = Fy[:] = 0;[4d#pragma unroll(tileSize)[5;5H// Loop over particles that exert force: vectorization expected here[6;5Hfor (int j = 0; j < nParticles; j++) {[7;9Hfor (int i = ii; i < ii + tileSize; i++){[8;7H// Avoid singularity and interaction with self[9;7Hconst float softening = 1e-20;[11;7H// Newton's law of universal gravity[12;7Hconst float dx = particle->x[j] - particle->x[i];[12;33H[A[A[9;33H[A[A[A[A[A[A	[2;21r[2;1H[10T[1;24r[3;3Hfloat *vx, *vy, *vz;[4d};[6dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[7;1H#pragma omp parallel for schedule(guided)[8;3H// Loop over particles that experience force[9;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[11;5H// Components of the gravity force on particle i[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[12;33H[A[A[9;33H[A[A[A[A[A};[3;24H[2;21r[2;1H[10T[1;24r[4;1H#include <cstdlib>[5d#include <cmath>[6d#include <cstdio>[7d#include <mkl_vsl.h>[8d#include <omp.h>[9d#define tileSize 16[11dstruct ParticleSet {[12;3Hfloat *x, *y, *z;[13;24H[14;3H[15d[16;33H[17d[18d[19d[20d[21;33H7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12;33H[13d[A[A[A[9;33H[10d[11;33H[12d[13d[A[Z[13d[Z[A[A[A[9;13H[A[9di =	0; ii <	n[10d[11;26H[12d[13d[14d[15d[16d[17d[18d[19d[20d[21;26H7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i];[13;7Hconst float dy = particle->y[j] - particle->y[i];[14;7Hconst float dz = particle->z[j] - particle->z[i];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12;26H[13d[14d[15d[16d[17;9H[18;26H[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H}[15d// Accelerate particles in response to the gravitational force[16;5Hparticle->vx[ii] += dt*Fx[ii];[17;5Hparticle->vy[ii] += dt*Fy[ii];[18;5Hparticle->vz[ii] += dt*Fz[ii];[19;3H}[20d}[21d // Move particles according to their velocities[12d[13;6H[14d[15;26H[16dt*Fx[i	[A[A[1;71H(B[0;7mModified[14d(B[mfor(int	k=0;k<tileSize;j k++_ ){[15d[16d[17d[18dz[i	];[19d[K[20d  }[21d}[K[19d}[A[A[A   par	icle-[A[A[15d[16d>v	[ii[1Pi[1Pk] += dt*Fx[ii];[16;19H[17d[1Pi[1Pk] += dt*Fy[ii];[17;19H[18di[1Pi[1Pk] += dt*Fz[ii];[18;19H] += 	t*Fz[iii];[K];[Kk];[Aii];[K];[Kk];[Aii];[K];[Kk];[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 135 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  7.085e+01  6.062e+07      1.2 *
^Cmake: *** [run-cpu] Interrupt
make: *** Deleting intermediate file `nbody.o'

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[19d#define tileSize 16[21dstruct ParticleSet {[22;32H(B[0;7m[ Read 135 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *x, *y, *z;[13;3Hfloat *vx, *vy, *vz;[14d};[16dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[17;1H#pragma omp parallel for schedule(guided)[18;3H// Loop over particles that experience force[19;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[21;5H// Components of the gravity force on particle i[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i];[13;7Hconst float dy = particle->y[j] - particle->y[i];[14;7Hconst float dz = particle->z[j] - particle->z[i];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H}[14dfor(int k=0;k<tileSize;k++){[15;5H// Accelerate particles in response to the gravitational force[16;5Hparticle->vx[k] += dt*Fx[k];[17;5Hparticle->vy[k] += dt*Fy[k];[18;5Hparticle->vz[k] += dt*Fz[k];[19d}[20d }[21d}[12d[13d[14d[15d[16d[17d[18d[19d[20d[21d7[2;22r8[22d[10S[1;24r[12;3H// Move particles according to their velocities[13;3H// O(N) work, so using a serial loop[15;3Hfor (int i = 0 ; i < nParticles; i++) {[16;5Hparticle->x[i]  += particle->vx[i]*dt;[17;5Hparticle->y[i]  += particle->vy[i]*dt;[18;5Hparticle->z[i]  += particle->vz[i]*dt;[19;3H}[20d}[12d[13d[14d [A[A[A[A[A[A[A[A[A[A[A[2;21r[2;1H[10T[1;24r[3;7Hconst float dy = particle->y[j] - particle->y[i];[4;7Hconst float dz = particle->z[j] - particle->z[i];[5;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[6;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[8;7H// Calculate the net force[9;7HFx[i-ii] += dx * drPowerN32;[10;7HFy[i-ii] += dy * drPowerN32;[11;7HFz[i-ii] += dz * drPowerN32;[12d[A [A[A[A[A[A [A[A[A[2;22r[2;1H[10T[1;24r[3;9HFx[:] = Fy[:] = Fy[:] = 0;[4d#pragma unroll(tileSize)[5;5H// Loop over particles that exert force: vectorization expected here[6;5Hfor (int j = 0; j < nParticles; j++) {[7;9Hfor (int i = ii; i < ii + tileSize; i++){[8;7H// Avoid singularity and interaction with self[9;7Hconst float softening = 1e-20;[11;7H// Newton's law of universal gravity[12;7Hconst float dx = particle->x[j] - particle->x[i]; [A[A[A [A[A[A [7d[8d [A[A [A[Apragma	unro[A[4d[5d[6d [7d[8d[9d[10d[11;14H[12d[13d[14d[15d[16d[17d	[18;14H[19d[A[A	[16;14H[Alo	t drRec	p  = 1.	f/[A[j] -	particl	->z[i[1;71H(B[0;7mModified[14;53H(B[mii];-];[Zi];[Z[Aii];-];[Zi];[Z[Aii];-];[Zi];[Z[13d[14d[15d[16d[Z[Z[Z[Z[Z[17d	[18;12H[19dii[A[A	[16;14H[A[A[Alo	t dy = 	article	>y[j] -	particl	->y[A[ii-i];[K[53Gi[3;7HFy[i-ii] += dy * drPowerN32[4;6H[1K Fz[i-ii] += dz * drPowerN32;[5d[K[6;5H}[K[7dfor(int k=0;k<tileSize;k++){[K[8;5H// Accelerate particles in response to the gravitational force[9;5Hparticle->vx[k] += dt*Fx[k];[K[10;5Hparticle->vy[k] += dt*Fy[k];[11;5Hparticle->vz[k] += dt*Fz[k];[K[12d}[K[13d }[K[14d}[K[15d // Move particles according to their velocities[K[16;3H// O(N) work, so using a serial loop[K[18;3Hfor (int i = 0 ; i < nParticles; i++) {[19;5Hparticle->x[i]  += particle->vx[i]*dt;[20;5Hparticle->y[i]  += particle->vy[i]*dt;[21;5Hparticle->z[i]  += particle->vz[i]*dt;[3d [2;21r[2;1H[10T[1;24r[4;7H// Newton's law of universal gravity[5;7Hconst float dx = particle->x[j] - particle->x[i-i];[6;7Hconst float dy = particle->y[j] - particle->y[ii-i];[7;7Hconst float dz = particle->z[j] - particle->z[ii-i];[8;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[9;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[11;7H// Calculate the net force[12;7HFx[i-ii] += dx * drPowerN32; [A[A[A [A[A[A[A     c	nst flo	t dx = 	article	>x[j] -	particl	->x[i-ii];[Z[6di-i];[K[54G-ii];[Z[7di-i];[K[54G-ii];[Z[8d[9d[10;9H[11;33H[12;37H[13d[14d[15d[16;6H[17;29H[18;56H[22d(B[0;7mSave modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                    [23;1H Y(B[m Yes[K[24d(B[0;7m N(B[m No  [14G   (B[0;7m^C(B[m Cancel[K[22;62H(B[0;7mFile Name to Write: nbody.cc                                [23d^G(B[m Get Help[23;21H(B[0;7mM-D(B[m DOS Format	(B[0;7mM-A(B[m Append[23;61H(B[0;7mM-B(B[m Backup File[24d(B[0;7m^C(B[m Cancel	    (B[0;7mM-M(B[m Mac Format	(B[0;7mM-P(B[m Prepend[22;29H[23d[39;49m(B[m[J[1;71H(B[0;7m        [22;30H(B[m[1K (B[0;7m[ Wrote 135 lines ](B[m[K[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ nano nbody.cc[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  6.924e+01  6.203e+07      1.2 *
^Cmake: *** [run-cpu] Interrupt
make: *** Deleting intermediate file `nbody.o'

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpunano nbody.cc
[?1049h[1;24r(B[m[4l[?7h[?12l[?25h[?1h=[?1h=[?1h=[39;49m[39;49m(B[m[H[2J(B[0;7m  GNU nano 2.3.1              File: nbody.cc                                    [3;1H(B[m/* Copyright (c) 2013-2015, Colfax International. All Right Reserved.[4dThis file, labs/4/4.01-overview-nbody/nbody.cc,[5dis a part of Supplementary Code for Practical Exercises for the handbook[6d"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",[7d2nd Edition -- 2015, Colfax International,[8dISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).[9dRedistribution or commercial usage without written permission[10dfrom Colfax International is prohibited.[11dContact information can be found at http://colfax-intl.com/     */[14d#include <cstdlib>[15d#include <cmath>[16d#include <cstdio>[17d#include <mkl_vsl.h>[18d#include <omp.h>[19d#define tileSize 16[21dstruct ParticleSet {[22;32H(B[0;7m[ Read 135 lines ][23d^G(B[m Get Help  (B[0;7m^O(B[m WriteOut  (B[0;7m^R(B[m Read File (B[0;7m^Y(B[m Prev Page (B[0;7m^K(B[m Cut Text  (B[0;7m^C(B[m Cur Pos[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^J(B[m Justify   (B[0;7m^W(B[m Where Is  (B[0;7m^V(B[m Next Page (B[0;7m^U(B[m UnCut Text(B[0;7m^T(B[m To Spell[3d[4d[5d[6d[7d[8d[9d[10d[11d[12d[13d[14d[15d[17d[18d[19d[20d[21d7[2;21r8[10S[1;24r[12;3Hfloat *x, *y, *z;[13;3Hfloat *vx, *vy, *vz;[14d};[16dvoid MoveParticles(const int nParticles, ParticleSet* const particle, const flo$[17;1H#pragma omp parallel for schedule(guided)[18;3H// Loop over particles that experience force[19;3Hfor (int ii = 0; ii < nParticles; ii+=tileSize) {[21;5H// Components of the gravity force on particle i[12d[13d[14d[15d[16d[17d[18d[22d[K[19d[20d[21d7[3;22r8[22d[10S[1;24r[12;5Hfloat Fx[tileSize], Fy[tileSize], Fz[tileSize];[13;9HFx[:] = Fy[:] = Fy[:] = 0;[14d#pragma unroll(tileSize)[15;5H// Loop over particles that exert force: vectorization expected here[16;5Hfor (int j = 0; j < nParticles; j++) {[17;9Hfor (int i = ii; i < ii + tileSize; i++){[18;7H// Avoid singularity and interaction with self[19;7Hconst float softening = 1e-20;[21;7H// Newton's law of universal gravity[12d[13d[14d[15d[16d[A[A[A[A[A[A[A  for (	nt ii[10d[11;14H[12dti	eSi[13d[14d[15d[16d j[17d[18d[19d[20d[21;22H7[3;22r8[22d[10S[1;24r[12;7Hconst float dx = particle->x[j] - particle->x[i-ii];[13;7Hconst float dy = particle->y[j] - particle->y[i-ii];[14;7Hconst float dz = particle->z[j] - particle->z[i-ii];[15;7Hconst float drRecip  = 1.0f/sqrtf(dx*dx + dy*dy + dz*dz + 1e-20f);[16;7Hconst float drPowerN32  = drRecip*drRecip*drRecip;[18;7H// Calculate the net force[19;7HFx[i-ii] += dx * drPowerN32;[20;7HFy[i-ii] += dy * drPowerN32;[21;7HFz[i-ii] += dz * drPowerN32;[12;22H[13d[14d[15d[16d[17;9H[18;22H[19d[20d[21d7[2;22r8[22d[10S[1;24r[2;1H[K[13;5H}[14dfor(int k=0;k<tileSize;k++){[15;5H// Accelerate particles in response to the gravitational force[16;5Hparticle->vx[k] += dt*Fx[k];[17;5Hparticle->vy[k] += dt*Fy[k];[18;5Hparticle->vz[k] += dt*Fz[k];[19d}[20d }[21d}[12d[13;6H[23d[J[24;80H[24;1H[?1049l[?1l>]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ vi nbody.cc
[?1049h[?1h=[2;1H▽[6n[1;1H  [1;1H[1;24r[?12;25h[?12l[?25h[27m[m[H[2J[?25l[24;1H"nbody.cc" 135L, 4884C[>c[1;7H[32mconst[m [32mfloat[m dx = particle->x[j] - particle->x[i-ii];[2;7H[32mconst[m [32mfloat[m dy = particle->y[j] - particle->y[i-ii];[3;7H[32mconst[m [32mfloat[m dz = particle->z[j] - particle->z[i-ii];[4;7H[32mconst[m [32mfloat[m drRecip  = [31m1.0f[m/sqrtf(dx*dx + dy*dy + dz*dz + [31m1e-20f[m);[5;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;[7;7H[34m// Calculate the net force[m[8;7HFx[i-ii] += dx * drPowerN32;[9;7HFy[i-ii] += dy * drPowerN32;[10;7HFz[i-ii] += dz * drPowerN32;[12;5H}
[33mfor[m([32mint[m k=[31m0[m;k<tileSize;k++){
    [34m// Accelerate particles in response to the gravitational force[m
    particle->vx[k] += dt*Fx[k];
    particle->vy[k] += dt*Fy[k];
    particle->vz[k] += dt*Fz[k];
}
  }
}
  [34m// Move particles according to their velocities
[m  [34m// O(N) work, so using a serial loop[m[24;63H51,5[10C34%[12;5H[?12l[?25h[?25l[24;64H2[13;5H[?12l[?25h[?25l[24;64H1[12;5H[?12l[?25h[?25l[24;64H2[13;5H[?12l[?25h[?25l[24;64H3[14;5H[?12l[?25h[?25l[24;66H6[14;6H[?12l[?25h[?25l[24;64H2[13;6H[?12l[?25h[?25l[24;64H1,5[12;5H[?12l[?25h[?25l[24;64H0,0-1[11;1H[?12l[?25h[?25l[24;63H49,6  [10;6H[?12l[?25h[?25l[24;64H8[9;6H[?12l[?25h[?25l[24;64H7[8;6H[?12l[?25h[?25l[24;64H6[7;6H[?12l[?25h[?25l[24;64H5,1-8[6;8H[?12l[?25h[?25l[24;64H4,6  [5;6H[?12l[?25h[?25l[24;64H3[4;6H[?12l[?25h[?25l[24;64H2[3;6H[?12l[?25h[?25l[24;64H1[2;6H[?12l[?25h[?25l[24;64H0[1;6H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[34m// Newton's law of universal gravity[m[24;1H[K[24;63H39,6[10C33%[1;6H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[24;63H[K[24;63H38,0-1[8C33%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[32mconst[m [32mfloat[m softening = [31m1e-20[m;[24;63H[K[24;63H37,6[10C32%[1;6H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[34m// Avoid singularity and interaction with self[m[24;63H[K[24;63H36,6[10C31%[1;6H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;9H[33mfor[m ([32mint[m i = ii; i < ii + tileSize; i++){[24;63H[K[24;63H35,1-8[8C30%[1;8H[?12l[?25h[?25l[24;64H6,6  [2;6H[?12l[?25h[?25l[24;64H5,1-8[1;8H[?12l[?25h[?25l[24;66H2-9[1;9H[?12l[?25h[?25l[24;66H3-10[1;10H[?12l[?25h[?25l[24;66H4-11[1;11H[?12l[?25h[?25l[24;66H5-12[1;12H[?12l[?25h[?25l [46m([34C)[m[24;66H6-13[1;13H[?12l[?25h[?25l([34C)[24;66H7-14[1;14H[?12l[?25h[?25l[24;66H8-15[1;15H[?12l[?25h[?25l[24;66H9-16[1;16H[?12l[?25h[?25l[24;66H10-17[1;17H[?12l[?25h[?25l[24;67H1-18[1;18H[?12l[?25h[?25l[24;67H2-19[1;19H[?12l[?25h[?25l[24;67H3-20[1;20H[?12l[?25h[?25l[24;67H4-21[1;21H[?12l[?25h[?25l[24;67H5-22[1;22H[?12l[?25h[?25l[24;67H6-23[1;23H[?12l[?25h[?25l[24;67H7-24[1;24H[?12l[?25h[?25l[24;67H8-25[1;25H[?12l[?25h[?25l[24;67H9-26[1;26H[?12l[?25h[?25l[24;66H20-27[1;27H[?12l[?25h[?25l[24;67H1-28[1;28H[?12l[?25h[?25l[24;67H2-29[1;29H[?12l[?25h[?25l[24;67H3-30[1;30H[?12l[?25h[?25l[24;67H4-31[1;31H[?12l[?25h[?25l[24;67H5-32[1;32H[?12l[?25h[?25l[24;67H6-33[1;33H[?12l[?25h[?25l[24;67H7-34[1;34H[?12l[?25h[?25l[24;67H8-35[1;35H[?12l[?25h[?25l[24;67H9-36[1;36H[?12l[?25h[?25l[24;66H30-37[1;37H[?12l[?25h[?25l[24;67H1-38[1;38H[?12l[?25h[?25l[24;67H2-39[1;39H[?12l[?25h[?25l[24;67H3-40[1;40H[?12l[?25h[?25l[24;67H4-41[1;41H[?12l[?25h[?25l[24;67H5-42[1;42H[?12l[?25h[?25l[24;67H6-43[1;43H[?12l[?25h[?25l[24;67H7-44[1;44H[?12l[?25h[?25l[24;67H8-45[1;45H[?12l[?25h[?25l[24;67H9-46[1;46H[?12l[?25h[?25l[24;66H40-47[1;47H[?12l[?25h[?25l[1;13H[46m([34C)[m[24;67H1-48[1;48H[?12l[?25h[?25l[1;13H([34C)[46m{[17;5H}[m[24;67H2-49[1;49H[?12l[?25h[?25l{[17;5H}[24;64H6,49   [2;49H[?12l[?25h[?25l[24;64H7,36[3;36H[?12l[?25h[?25l[24;64H8,0-1[4;1H[?12l[?25h[?25l[24;64H9,42 [5;42H[?12l[?25h[?25l[24;63H40,49[6;49H[?12l[?25h[?25l[24;64H1[7;49H[?12l[?25h[?25l[24;64H2[8;49H[?12l[?25h[?25l[24;64H3[9;49H[?12l[?25h[?25l[24;64H4[10;49H[?12l[?25h[?25l[24;64H5,1-8[11;8H[?12l[?25h[?25l[24;64H6,32 [12;32H[?12l[?25h[?25l[24;64H7,36[13;36H[?12l[?25h[?25l[24;64H8[14;36H[?12l[?25h[?25l[24;64H9,34[15;34H[?12l[?25h[?25l[24;63H50,0-1[16;1H[?12l[?25h[?25l[1;49H[46m{[17;5H}[m[24;64H1,5  [17;5H[?12l[?25h[?25l[1;49H{[17;5H}[18;28H[46m{[23;1H}[m[24;64H2,28[18;28H[?12l[?25h[?25l{[23;1H}[24;64H3,49[19;49H[?12l[?25h[?25l[24;64H4,33[20;33H[?12l[?25h[?25l[24;64H5[21;33H[?12l[?25h[?25l[24;64H6,32[22;32H[?12l[?25h[?25l[24;64H5,33[21;33H[?12l[?25h[?25l[24;64H4[20;33H[?12l[?25h[?25l[24;64H3,49[19;49H[?12l[?25h[?25l[24;67H8[19;48H[?12l[?25h[?25l[18;28H[46m{[23;1H}[m[24;64H2,2[18;28H[?12l[?25h[?25l[18;4H[46m([22C)[m{[23;1H}[24;67H7[18;27H[?12l[?25h[?25l[18;4H([22C)[24;67H6[18;26H[?12l[?25h[?25l[24;67H5[18;25H[?12l[?25h[?25l[24;67H4[18;24H[?12l[?25h[?25l[24;67H3[18;23H[?12l[?25h[?25l[24;67H2[18;22H[?12l[?25h[?25l[24;67H1[18;21H[?12l[?25h[?25l[24;67H0[18;20H[?12l[?25h[?25l[24;66H19[18;19H[?12l[?25h[?25l[24;67H8[18;18H[?12l[?25h[?25l[24;67H7[18;17H[?12l[?25h[?25l[24;67H6[18;16H[?12l[?25h[?25l[24;67H5[18;15H[?12l[?25h[?25l[24;67H4[18;14H[?12l[?25h[?25l[24;67H3[18;13H[?12l[?25h[?25l[24;67H2[18;12H[?12l[?25h[?25l[24;67H1[18;11H[?12l[?25h[?25l[24;67H0[18;10H[?12l[?25h[?25l[24;66H9 [18;9H[?12l[?25h[?25l=[31m0[m;k<tileSize;k++){[18;28H[K[18;9H[?12l[?25h[?25l[24;1H[1m-- INSERT --[m[24;63H[K[24;63H52,9[10C30%[18;9H[?12l[?25h[?25li=[31m0[m;k<tileSize;k++){[24;66H10[18;10H[?12l[?25h[?25l[24;67H1[18;11H[?12l[?25h[?25l[24;67H2[18;12H[?12l[?25h[?25l[24;67H3[18;13H[?12l[?25h[?25l<tileSize;k++){[18;28H[K[18;13H[?12l[?25h[?25li<tileSize;k++){[24;67H4[18;14H[?12l[?25h[?25l[24;67H5[18;15H[?12l[?25h[?25l[24;67H6[18;16H[?12l[?25h[?25l[24;67H7[18;17H[?12l[?25h[?25l[24;67H8[18;18H[?12l[?25h[?25l[24;67H9[18;19H[?12l[?25h[?25l[24;66H20[18;20H[?12l[?25h[?25l[24;67H1[18;21H[?12l[?25h[?25l[24;67H2[18;22H[?12l[?25h[?25l[24;67H3[18;23H[?12l[?25h[?25l[24;67H4[18;24H[?12l[?25h[?25l++){[18;28H[K[18;24H[?12l[?25h[?25li++){[24;67H5[18;25H[?12l[?25h[?25l[24;67H4[18;24H[?12l[?25h[?25l[24;67H3[18;23H[?12l[?25h[?25l[24;67H2[18;22H[?12l[?25h[?25l[24;67H1[18;21H[?12l[?25h[?25l[24;67H0[18;20H[?12l[?25h[?25l[24;66H19[18;19H[?12l[?25h[?25l[24;67H8[18;18H[?12l[?25h[?25l[24;67H7[18;17H[?12l[?25h[?25l[24;67H6[18;16H[?12l[?25h[?25l[24;67H5[18;15H[?12l[?25h[?25l[24;67H4[18;14H[?12l[?25h[?25l[24;67H3[18;13H[?12l[?25h[?25l[24;67H2[18;12H[?12l[?25h[?25l[24;67H1[18;11H[?12l[?25h[?25l;i<tileSize;i++){[18;28H[K[18;11H[?12l[?25h[?25li;i<tileSize;i++){[24;67H2[18;12H[?12l[?25h[?25li;i<tileSize;i++){[24;67H3[18;13H[?12l[?25h[?25l[24;67H4[18;14H[?12l[?25h[?25l[24;67H5[18;15H[?12l[?25h[?25l[24;67H6[18;16H[?12l[?25h[?25l[24;67H7[18;17H[?12l[?25h[?25l[24;67H8[18;18H[?12l[?25h[?25l[24;67H9[18;19H[?12l[?25h[?25l[24;66H20[18;20H[?12l[?25h[?25l[24;67H1[18;21H[?12l[?25h[?25l[24;67H2[18;22H[?12l[?25h[?25l[24;67H3[18;23H[?12l[?25h[?25l+e;i++){[24;67H4[18;24H[?12l[?25h[?25lie;i++){[24;67H5[18;25H[?12l[?25h[?25lie;i++){[24;67H6[18;26H[?12l[?25h[?25l;i++){[18;32H[K[18;26H[?12l[?25h[?25l[24;67H5[18;25H[?12l[?25h[?25l[24;67H4[18;24H[?12l[?25h[?25l[24;67H3[18;23H[?12l[?25h[?25l[24;67H2[18;22H[?12l[?25h[?25l[24;67H1[18;21H[?12l[?25h[?25l[24;67H2[18;22H[?12l[?25h[?25l[24;67H3[18;23H[?12l[?25h[?25le+ii;i++){[24;67H4[18;24H[?12l[?25h[?25l[24;67H5[18;25H[?12l[?25h[?25l[24;67H6[18;26H[?12l[?25h[?25l[24;67H7[18;27H[?12l[?25h[?25l[24;67H8[18;28H[?12l[?25h[24;1H[K[18;27H[?25l[24;63H52,27[9C30%[18;27H[?12l[?25h[?25l[24;64H3[19;27H[?12l[?25h[?25l[24;64H4[20;27H[?12l[?25h[?25l[24;67H6[20;26H[?12l[?25h[?25l[24;67H5[20;25H[?12l[?25h[?25l[24;67H4[20;24H[?12l[?25h[?25l[24;67H3[20;23H[?12l[?25h[?25l[24;67H2[20;22H[?12l[?25h[?25l[24;67H1[20;21H[?12l[?25h[?25l[24;67H0[20;20H[?12l[?25h[?25l[46m[[mk[46m][m[24;66H19[20;19H[?12l[?25h[?25l[k][24;67H8[20;18H[?12l[?25h[?25l[24;1H[1m-- INSERT --[m[24;63H[K[24;63H54,18[9C30%[20;18H[?12l[?25h[?25l[46m[[mk[46m][m[24;67H9[20;19H[?12l[?25h[?25l][46m [m+= dt*Fx[k]; [20;18H[46m][m [24;67H8[20;18H[?12l[?25h[?25l[46mi[m] += dt*Fx[k];[20;18Hi[46m][m[24;67H9[20;19H[?12l[?25h[?25l[i][21;17H[46m[[mk[46m][m[24;64H5[21;19H[?12l[?25h[?25l][46m [m+= dt*Fy[k]; [21;18H[46m][m [24;67H8[21;18H[?12l[?25h[?25l[46mi[m] += dt*Fy[k];[21;18Hi[46m][m[24;67H9[21;19H[?12l[?25h[?25l[i][22;17H[46m[[mk[46m][m[24;64H6[22;19H[?12l[?25h[?25l][46m [m+= dt*Fz[k];[22;32H[K[22;18H[46m][m [24;67H8[22;18H[?12l[?25h[?25l[46mi[m] += dt*Fz[k];[22;18Hi[46m][m[24;67H9[22;19H[?12l[?25h[?25l[24;63H[K[24;63H56,20[9C30%[22;20H[?12l[?25h[?25l[i][24;67H1[22;21H[?12l[?25h[?25l[24;67H2[22;22H[?12l[?25h[?25l[24;67H3[22;23H[?12l[?25h[?25l[24;67H4[22;24H[?12l[?25h[?25l[24;67H5[22;25H[?12l[?25h[?25l[24;67H6[22;26H[?12l[?25h[?25l[24;67H7[22;27H[?12l[?25h[?25l[24;67H8[22;28H[?12l[?25h[?25lz[46m[[mk[46m][m[24;67H9[22;29H[?12l[?25h[?25l[24;63H[K[24;63H56,30[9C30%[22;30H[?12l[?25h[?25l[24;67H1[22;31H[?12l[?25h[?25l][46m;[m[22;32H[K[22;30H[46m][m;[24;67H0[22;30H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H1[22;31H[?12l[?25h[?25l[21;29H[46m[[mk[46m][m[22;29H[i][24;64H5[21;31H[?12l[?25h[?25l][46m;[m [46m][m;[24;67H0[21;30H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H1[21;31H[?12l[?25h[?25l[20;29H[46m[[mk[46m][m[21;29H[i][24;64H4[20;31H[?12l[?25h[?25l][46m;[m [46m][m;[24;67H0[20;30H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H1[20;31H[?12l[?25h[24;1H[K[20;30H[?25l[i][24;63H54,30[9C30%[20;30H[?12l[?25h[?25l[24;63H[K[24;1H:[?12l[?25hw[?25l[?12l[?25hq[?25l[?12l[?25h[?25l"nbody.cc" 135L, 4888C written
[?1l>[?12l[?25h[?1049l]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ vi nbody.cc[Kvi nbody.cc[2@nano[C[C[C[C[C[C[C[C[C[1Pmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
^Cmake: *** [run-cpu] Segmentation fault (core dumped)
make: *** Deleting intermediate file `nbody.o'

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ make run-cpu[1Pvi nbody.cc
[?1049h[?1h=[2;1H▽[6n[1;1H  [1;1H[1;24r[?12;25h[?12l[?25h[27m[m[H[2J[?25l[24;1H"nbody.cc" 135L, 4888C[>c[1;7H[32mconst[m [32mfloat[m drRecip  = [31m1.0f[m/sqrtf(dx*dx + dy*dy + dz*dz + [31m1e-20f[m);[2;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;[4;7H[34m// Calculate the net force[m[5;7HFx[i-ii] += dx * drPowerN32;[6;7HFy[i-ii] += dy * drPowerN32;[7;7HFz[i-ii] += dz * drPowerN32;[9;5H}
[33mfor[m([32mint[m i=ii;i<tileSize+ii;i++){
    [34m// Accelerate particles in response to the gravitational force[m
    particle->vx[i] += dt*Fx[i];
    particle->vy[i] += dt*Fy[i];
    particle->vz[i] += dt*Fz[i];
}
  }
}
  [34m// Move particles according to their velocities
[m  [34m// O(N) work, so using a serial loop[m

  [33mfor[m ([32mint[m i = [31m0[m ; i < nParticles; i++) {
    particle->x[i]  += particle->vx[i]*dt;
    particle->y[i]  += particle->vy[i]*dt;[24;63H54,5[10C37%[12;5H[?12l[?25h[?25l[24;64H5[13;5H[?12l[?25h[?25l[24;64H6[14;5H[?12l[?25h[?25l[10;32H[46m{[15;1H}[m[24;64H7,1[15;1H[?12l[?25h[?25l[10;32H{[15;1H}[24;64H8,3[16;3H[?12l[?25h[?25l[24;64H9,1[17;1H[?12l[?25h[?25l[24;63H60,5[18;5H[?12l[?25h[?25l[24;64H1[19;5H[?12l[?25h[?25l[24;64H2,1[20;1H[?12l[?25h[?25l[24;64H3,5[21;5H[?12l[?25h[?25l[24;64H4[22;5H[?12l[?25h[?25l[24;64H5[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;5Hparticle->z[i]  += particle->vz[i]*dt;[24;1H[K[24;63H66,5[10C38%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[19;41H[46m{[23;3H}[m[24;63H[K[24;63H67,3[10C39%[23;3H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[18;41H{[22;3H}
}[24;63H[K[24;63H68,1[10C40%[23;1H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[24;63H[K[24;63H69,0-1[8C41%[23;1H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;1H[32mint[m main([32mconst[m [32mint[m argc, [32mconst[m [32mchar[m** argv) {[24;63H[K[24;63H70,5[10C41%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[24;63H[K[24;63H71,0-1[8C42%[23;1H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[34m// Problem size and other parameters[m[24;63H[K[24;63H72,5[10C43%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[32mconst[m [32mint[m nParticles = (argc > [31m1[m ? atoi(argv[[31m1[m]) : [31m16384[m);[24;63H[K[24;63H73,5[10C44%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[32mconst[m [32mint[m nSteps = [31m10[m;  [34m// Duration of test[m[24;63H[K[24;63H74,5[10C45%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[32mconst[m [32mfloat[m dt = [31m0.01f[m; [34m// Particle propagation time step[m[24;63H[K[24;63H75,5[10C46%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[24;63H[K[24;63H76,0-1[8C47%[23;1H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[34m// Particle data stored as an Array of Structures (AoS)[m[24;63H[K[24;63H77,5[10C48%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[34m// this is good object-oriented programming style,[m[24;63H[K[24;63H78,5[10C49%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[34m// but inefficient for the purposes of vectorization[m[24;63H[K[24;63H79,5[10C50%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3HParticleSet* particle = [33mnew[m ParticleSet[[31m1[m];[24;63H[K[24;63H80,5[10C50%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3Hparticle->x = [33mnew[m [32mfloat[m[nParticles];[24;63H[K[24;63H81,5[10C51%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3Hparticle->y = [33mnew[m [32mfloat[m[nParticles];[24;63H[K[24;63H82,5[10C52%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3Hparticle->z = [33mnew[m [32mfloat[m[nParticles];[24;63H[K[24;63H83,5[10C53%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3Hparticle->vx = [33mnew[m [32mfloat[m[nParticles];[24;63H[K[24;63H84,5[10C54%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3Hparticle->vy = [33mnew[m [32mfloat[m[nParticles];[24;63H[K[24;63H85,5[10C55%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3Hparticle->vz = [33mnew[m [32mfloat[m[nParticles];[24;63H[K[24;63H86,5[10C56%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[24;63H[K[24;63H87,0-1[8C57%[23;1H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[34m// Initialize random number generator and particles[m[24;63H[K[24;63H88,5[10C58%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3HVSLStreamStatePtr rnStream;[24;63H[K[24;63H89,5[10C58%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3HvslNewStream( &rnStream, VSL_BRNG_MT19937, [31m1[m );[24;63H[K[24;63H90,5[10C59%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[34m//vsRngUniform(VSL_RNG_METHOD_UNIFORM_STD, [m[24;63H[K[24;63H91,5[10C60%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;15H[34m//rnStream, 6*nParticles, (float*)particle, -1.0f, 1.0f);[m[24;63H[K[24;63H92,1-8[8C61%[23;8H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[24;63H[K[24;63H93,2[10C62%[23;2H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[34m// Perform benchmark[m[24;63H[K[24;63H94,5[10C63%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3Hprintf([31m"[m[35m\n\033[m[31m[1mNBODY Version 00[m[35m\033[m[31m[0m[m[35m\n[m[31m"[m);[24;63H[K[24;63H95,5[10C64%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3Hprintf([31m"[m[35m\n[m[31mPropagating [m[35m%d[m[31m particles using 1 thread on [m[35m%s[m[31m...[m[35m\n\n[m[31m"[m,[24;63H[K[24;63H96,5[10C65%[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;10HnParticles,[24;63H[K[24;63H97,1-8[8C66%[23;8H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;1H[35m#ifndef __MIC__[m[24;63H[K[24;63H98,5[10C66%[23;5H[?12l[?25h[?25l[24;64H7,1-8[22;8H[?12l[?25h[?25l[24;64H6,5  [21;5H[?12l[?25h[?25l[24;64H5[20;5H[?12l[?25h[?25l[24;64H4[19;5H[?12l[?25h[?25l[24;64H3,2[18;2H[?12l[?25h[?25l[24;64H2,1-8[17;8H[?12l[?25h[?25l[24;64H1,5  [16;5H[?12l[?25h[?25l[24;64H0[15;5H[?12l[?25h[?25l[24;63H89[14;5H[?12l[?25h[?25l[24;64H8[13;5H[?12l[?25h[?25l[24;64H7,0-1[12;1H[?12l[?25h[?25l[24;64H6,5  [11;5H[?12l[?25h[?25l[24;64H5[10;5H[?12l[?25h[?25l[24;64H4[9;5H[?12l[?25h[?25l[24;64H3[8;5H[?12l[?25h[?25l[24;64H2[7;5H[?12l[?25h[?25l[24;64H1[6;5H[?12l[?25h[?25l[24;64H0[5;5H[?12l[?25h[?25l[24;63H79[4;5H[?12l[?25h[?25l[24;64H8[3;5H[?12l[?25h[?25l[24;64H7[2;5H[?12l[?25h[?25l[24;64H6,0-1[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H[32mconst[m [32mfloat[m dt = [31m0.01f[m; [34m// Particle propagation time step[m[24;63H[K[24;63H75,5[10C66%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H[32mconst[m [32mint[m nSteps = [31m10[m;  [34m// Duration of test[m[24;63H[K[24;63H74,5[10C65%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H[32mconst[m [32mint[m nParticles = (argc > [31m1[m ? atoi(argv[[31m1[m]) : [31m16384[m);[24;63H[K[24;63H73,5[10C64%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H[34m// Problem size and other parameters[m[24;63H[K[24;63H72,5[10C63%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[24;63H[K[24;63H71,0-1[8C62%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;1H[32mint[m main([32mconst[m [32mint[m argc, [32mconst[m [32mchar[m** argv) {[24;63H[K[24;63H70,5[10C61%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[24;63H[K[24;63H69,0-1[8C60%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;1H}[24;63H[K[24;63H68,1[10C59%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H}[24;63H[K[24;63H67,3[10C58%[1;3H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5Hparticle->z[i]  += particle->vz[i]*dt;[24;63H[K[24;63H66,5[10C58%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5Hparticle->y[i]  += particle->vy[i]*dt;[24;63H[K[24;63H65,5[10C57%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5Hparticle->x[i]  += particle->vx[i]*dt;[24;63H[K[24;63H64,5[10C56%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H[33mfor[m ([32mint[m i = [31m0[m ; i < nParticles; i++) {[24;63H[K[24;63H63,5[10C55%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[24;63H[K[24;63H62,1[10C54%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H[34m// O(N) work, so using a serial loop[m[24;63H[K[24;63H61,5[10C53%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H[34m// Move particles according to their velocities[m[24;63H[K[24;63H60,5[10C52%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;1H}[24;63H[K[24;63H59,1[10C51%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;3H}[24;63H[K[24;63H58,3[10C50%[1;3H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;1H}[24;63H[K[24;63H57,1[10C50%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5Hparticle->vz[i] += dt*Fz[i];[24;63H[K[24;63H56,5[10C49%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5Hparticle->vy[i] += dt*Fy[i];[24;63H[K[24;63H55,5[10C48%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5Hparticle->vx[i] += dt*Fx[i];[24;63H[K[24;63H54,5[10C47%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5H[34m// Accelerate particles in response to the gravitational force[m[24;63H[K[24;63H53,5[10C46%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;1H[33mfor[m([32mint[m i=ii;i<tileSize+ii;i++){[24;63H[K[24;63H52,5[10C45%[1;5H[?12l[?25h[?25l[24;64H3[2;5H[?12l[?25h[?25l[24;64H2[1;5H[?12l[?25h[?25l[24;64H3[2;5H[?12l[?25h[?25l[24;64H4[3;5H[?12l[?25h[?25l[24;64H5[4;5H[?12l[?25h[?25l[24;64H6[5;5H[?12l[?25h[?25l[1;32H[46m{[6;1H}[m[24;64H7,1[6;1H[?12l[?25h[?25l[1;32H{[6;1H}[24;64H8,3[7;3H[?12l[?25h[?25l[24;64H9,1[8;1H[?12l[?25h[?25l[24;63H60,5[9;5H[?12l[?25h[?25l[24;64H1[10;5H[?12l[?25h[?25l[24;64H2,1[11;1H[?12l[?25h[?25l[24;64H3,5[12;5H[?12l[?25h[?25l[24;64H4[13;5H[?12l[?25h[?25l[24;66H6[13;6H[?12l[?25h[?25l[24;66H7[13;7H[?12l[?25h[?25l[24;66H8[13;8H[?12l[?25h[?25l[24;66H9[13;9H[?12l[?25h[?25l[24;66H10[13;10H[?12l[?25h[?25l[24;67H1[13;11H[?12l[?25h[?25l[24;67H2[13;12H[?12l[?25h[?25l[24;67H3[13;13H[?12l[?25h[?25l[24;67H4[13;14H[?12l[?25h[?25l[24;67H5[13;15H[?12l[?25h[?25lx[46m[[mi[46m][m[24;67H6[13;16H[?12l[?25h[?25l[i][24;67H7[13;17H[?12l[?25h[?25l[24;64H3[12;17H[?12l[?25h[?25l[24;64H2,1 [11;1H[?12l[?25h[?25l[24;64H1,17[10;17H[?12l[?25h[?25l[24;64H0[9;17H[?12l[?25h[?25l[24;63H59,1 [8;1H[?12l[?25h[?25l[24;64H8,3[7;3H[?12l[?25h[?25l[1;32H[46m{[6;1H}[m[24;64H7,1[6;1H[?12l[?25h[?25l[1;32H{[5;17H[46m[[mi[46m][m
}[24;64H6,17[5;17H[?12l[?25h[?25l[4;17H[46m[[mi[46m][m[5;17H[i][24;64H5[4;17H[?12l[?25h[?25l[3;17H[46m[[mi[46m][m[4;17H[i][24;64H4[3;17H[?12l[?25h[?25l[i][24;64H3[2;17H[?12l[?25h[?25l[24;64H2[1;17H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5H}[24;63H[K[24;63H51,5[10C44%[1;5H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[24;63H[K[24;63H50,0-1[8C43%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7HFz[i-ii] += dz * drPowerN32;[24;63H[K[24;63H49,17[9C42%[1;17H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7HFy[i-ii] += dy * drPowerN32;[24;63H[K[24;63H48,17[9C41%[1;17H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7HFx[i-ii] += dx * drPowerN32;[24;63H[K[24;63H47,17[9C41%[1;17H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[34m// Calculate the net force[m[24;63H[K[24;63H46,17[9C40%[1;17H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[24;63H[K[24;63H45,1-8[8C39%[1;8H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;[24;63H[K[24;63H44,17[9C38%[1;17H[?12l[?25h[?25l[24;64H5,1-8[2;8H[?12l[?25h[?25l[24;64H6,17 [3;17H[?12l[?25h[?25l[24;64H7[4;17H[?12l[?25h[?25l[24;64H8[5;17H[?12l[?25h[?25l[24;64H9[6;17H[?12l[?25h[?25l[24;63H50,0-1[7;1H[?12l[?25h[?25l[24;64H1,5  [8;5H[?12l[?25h[?25l[24;64H2,17[9;17H[?12l[?25h[?25l[24;64H3[10;17H[?12l[?25h[?25l[11;17H[46m[[mi[46m][m[24;64H4[11;17H[?12l[?25h[?25l[i][24;67H8[11;18H[?12l[?25h[?25l[24;1H[1m-- INSERT --[m[24;63H[K[24;63H54,19[9C38%[11;17H[46m[[mi[46m][?12l[?25h[?25l-[m] += dt*Fx[i];[11;19H-[46m][m[24;66H20[11;20H[?12l[?25h[?25l[46mi[m] += dt*Fx[i];[11;20Hi[46m][m[24;67H1[11;21H[?12l[?25h[?25l[46mi[m] += dt*Fx[i];[11;21Hi[46m][m[24;67H2[11;22H[?12l[?25h[?25l[i-ii][24;64H3[10;22H[?12l[?25h[?25l[27m[m[H[2J[1;1H[32mvoid[m MoveParticles([32mconst[m [32mint[m nParticles, ParticleSet* [32mconst[m particle, [32mconst[m [32mfloaa[2;1Ht[m dt) {
[35m#pragma omp parallel [m[33mfor[m[35m schedule(guided)[m
  [34m// Loop over particles that experience force[m
  [33mfor[m ([32mint[m ii = [31m0[m; ii < nParticles; ii+=tileSize) {[7;5H[34m// Components of the gravity force on particle i[m
    [32mfloat[m Fx[tileSize], Fy[tileSize], Fz[tileSize];[9;9HFx[:] = Fy[:] = Fy[:] = [31m0[m;
[35m#pragma unroll(tileSize)      [m
    [34m// Loop over particles that exert force: vectorization expected here[m
    [33mfor[m ([32mint[m j = [31m0[m; j < nParticles; j++) {[13;9H[33mfor[m ([32mint[m i = ii; i < ii + tileSize; i++){[14;7H[34m// Avoid singularity and interaction with self[m[15;7H[32mconst[m [32mfloat[m softening = [31m1e-20[m;[17;7H[34m// Newton's law of universal gravity[m[18;7H[32mconst[m [32mfloat[m dx = particle->x[j] - particle->x[i-ii];[19;7H[32mconst[m [32mfloat[m dy = particle->y[j] - particle->y[i-ii];[20;7H[32mconst[m [32mfloat[m dz = particle->z[j] - particle->z[i-ii];[21;7H[32mconst[m [32mfloat[m drRecip  = [31m1.0f[m/sqrtf(dx*dx + dy*dy + dz*dz + [31m1e-20f[m);[22;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;

[1m-- INSERT --[m[50C45,1[10C20%[23;1H[?12l[?25h[?25l[27m[m[H[2J[1;1H[34m"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",
2nd Edition -- 2015, Colfax International,
ISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).
Redistribution or commercial usage without written permission 
from Colfax International is prohibited.
Contact information can be found at http://colfax-intl.com/     */[m


[35m#include [m[31m<cstdlib>[m
[35m#include [m[31m<cmath>[m
[35m#include [m[31m<cstdio>[m
[35m#include [m[31m<mkl_vsl.h>[m
[35m#include [m[31m<omp.h>[m
[35m#define tileSize [m[31m16[m

[32mstruct[m ParticleSet {
  [32mfloat[m *x, *y, *z;
  [32mfloat[m *vx, *vy, *vz;
};

[32mvoid[m MoveParticles([32mconst[m [32mint[m nParticles, ParticleSet* [32mconst[m particle, [32mconst[m [32mfloaa[22;1Ht[m dt) {
[35m#pragma omp parallel [m[33mfor[m[35m schedule(guided)[m
[1m-- INSERT --[m[50C25,1[11C2%[23;1H[?12l[?25h[?25l[27m[m[H[2J[1;1H[32mvoid[m MoveParticles([32mconst[m [32mint[m nParticles, ParticleSet* [32mconst[m particle, [32mconst[m [32mfloaa[2;1Ht[m dt) {
[35m#pragma omp parallel [m[33mfor[m[35m schedule(guided)[m
  [34m// Loop over particles that experience force[m
  [33mfor[m ([32mint[m ii = [31m0[m; ii < nParticles; ii+=tileSize) {[7;5H[34m// Components of the gravity force on particle i[m
    [32mfloat[m Fx[tileSize], Fy[tileSize], Fz[tileSize];[9;9HFx[:] = Fy[:] = Fy[:] = [31m0[m;
[35m#pragma unroll(tileSize)      [m
    [34m// Loop over particles that exert force: vectorization expected here[m
    [33mfor[m ([32mint[m j = [31m0[m; j < nParticles; j++) {[13;9H[33mfor[m ([32mint[m i = ii; i < ii + tileSize; i++){[14;7H[34m// Avoid singularity and interaction with self[m[15;7H[32mconst[m [32mfloat[m softening = [31m1e-20[m;[17;7H[34m// Newton's law of universal gravity[m[18;7H[32mconst[m [32mfloat[m dx = particle->x[j] - particle->x[i-ii];[19;7H[32mconst[m [32mfloat[m dy = particle->y[j] - particle->y[i-ii];[20;7H[32mconst[m [32mfloat[m dz = particle->z[j] - particle->z[i-ii];[21;7H[32mconst[m [32mfloat[m drRecip  = [31m1.0f[m/sqrtf(dx*dx + dy*dy + dz*dz + [31m1e-20f[m);[22;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;

[1m-- INSERT --[m[50C24,1[10C20%[1;1H[?12l[?25h[?25l[27m[m[H[2J[1;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;[3;7H[34m// Calculate the net force[m[4;7HFx[i-ii] += dx * drPowerN32;[5;7HFy[i-ii] += dy * drPowerN32;[6;7HFz[i-ii] += dz * drPowerN32;[8;5H}
[33mfor[m([32mint[m i=ii;i<tileSize+ii;i++){
    [34m// Accelerate particles in response to the gravitational force[m
    particle->vx[i-ii] += dt*Fx[i];
    particle->vy[i] += dt*Fy[i];
    particle->vz[i] += dt*Fz[i];
}
  }
}
  [34m// Move particles according to their velocities
[m  [34m// O(N) work, so using a serial loop[m

  [33mfor[m ([32mint[m i = [31m0[m ; i < nParticles; i++) {
    particle->x[i]  += particle->vx[i]*dt;
    particle->y[i]  += particle->vy[i]*dt;
    particle->z[i]  += particle->vz[i]*dt;
[1m-- INSERT --[m[50C44,7[10C38%[1;7H[?12l[?25h[?25l[24;64H5,1[2;1H[?12l[?25h[?25l[24;64H6,7[3;7H[?12l[?25h[?25l[24;64H7[4;7H[?12l[?25h[?25l[24;64H6[3;7H[?12l[?25h[?25l[24;64H7[4;7H[?12l[?25h[?25l[24;64H8[5;7H[?12l[?25h[?25l[24;64H9[6;7H[?12l[?25h[?25l[24;63H50,1[7;1H[?12l[?25h[?25l[24;63H[K[24;63H51,6[10C38%[8;6H[?12l[?25h[?25l[24;64H2,7[9;7H[?12l[?25h[?25l[24;64H3[10;7H[?12l[?25h[?25l[24;64H4[11;7H[?12l[?25h[?25l[24;66H37[11;37H[?12l[?25h[?25l[27m[m[H[2J[1;1H[32mvoid[m MoveParticles([32mconst[m [32mint[m nParticles, ParticleSet* [32mconst[m particle, [32mconst[m [32mfloaa[2;1Ht[m dt) {
[35m#pragma omp parallel [m[33mfor[m[35m schedule(guided)[m
  [34m// Loop over particles that experience force[m
  [33mfor[m ([32mint[m ii = [31m0[m; ii < nParticles; ii+=tileSize) {[7;5H[34m// Components of the gravity force on particle i[m
    [32mfloat[m Fx[tileSize], Fy[tileSize], Fz[tileSize];[9;9HFx[:] = Fy[:] = Fy[:] = [31m0[m;
[35m#pragma unroll(tileSize)      [m
    [34m// Loop over particles that exert force: vectorization expected here[m
    [33mfor[m ([32mint[m j = [31m0[m; j < nParticles; j++) {[13;9H[33mfor[m ([32mint[m i = ii; i < ii + tileSize; i++){[14;7H[34m// Avoid singularity and interaction with self[m[15;7H[32mconst[m [32mfloat[m softening = [31m1e-20[m;[17;7H[34m// Newton's law of universal gravity[m[18;7H[32mconst[m [32mfloat[m dx = particle->x[j] - particle->x[i-ii];[19;7H[32mconst[m [32mfloat[m dy = particle->y[j] - particle->y[i-ii];[20;7H[32mconst[m [32mfloat[m dz = particle->z[j] - particle->z[i-ii];[21;7H[32mconst[m [32mfloat[m drRecip  = [31m1.0f[m/sqrtf(dx*dx + dy*dy + dz*dz + [31m1e-20f[m);[22;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;

[1m-- INSERT --[m[50C45,1[10C20%[23;1H[?12l[?25h[?25l[27m[m[H[2J[1;1H[34m"Parallel Programming and Optimization with Intel Xeon Phi Coprocessors",
2nd Edition -- 2015, Colfax International,
ISBN 9780988523401 (paper), 9780988523425 (PDF), 9780988523432 (Kindle).
Redistribution or commercial usage without written permission 
from Colfax International is prohibited.
Contact information can be found at http://colfax-intl.com/     */[m


[35m#include [m[31m<cstdlib>[m
[35m#include [m[31m<cmath>[m
[35m#include [m[31m<cstdio>[m
[35m#include [m[31m<mkl_vsl.h>[m
[35m#include [m[31m<omp.h>[m
[35m#define tileSize [m[31m16[m

[32mstruct[m ParticleSet {
  [32mfloat[m *x, *y, *z;
  [32mfloat[m *vx, *vy, *vz;
};

[32mvoid[m MoveParticles([32mconst[m [32mint[m nParticles, ParticleSet* [32mconst[m particle, [32mconst[m [32mfloaa[22;1Ht[m dt) {
[35m#pragma omp parallel [m[33mfor[m[35m schedule(guided)[m
[1m-- INSERT --[m[50C25,1[11C2%[23;1H[?12l[?25h[?25l[27m[m[H[2J[1;1H[32mvoid[m MoveParticles([32mconst[m [32mint[m nParticles, ParticleSet* [32mconst[m particle, [32mconst[m [32mfloaa[2;1Ht[m dt) {
[35m#pragma omp parallel [m[33mfor[m[35m schedule(guided)[m
  [34m// Loop over particles that experience force[m
  [33mfor[m ([32mint[m ii = [31m0[m; ii < nParticles; ii+=tileSize) {[7;5H[34m// Components of the gravity force on particle i[m
    [32mfloat[m Fx[tileSize], Fy[tileSize], Fz[tileSize];[9;9HFx[:] = Fy[:] = Fy[:] = [31m0[m;
[35m#pragma unroll(tileSize)      [m
    [34m// Loop over particles that exert force: vectorization expected here[m
    [33mfor[m ([32mint[m j = [31m0[m; j < nParticles; j++) {[13;9H[33mfor[m ([32mint[m i = ii; i < ii + tileSize; i++){[14;7H[34m// Avoid singularity and interaction with self[m[15;7H[32mconst[m [32mfloat[m softening = [31m1e-20[m;[17;7H[34m// Newton's law of universal gravity[m[18;7H[32mconst[m [32mfloat[m dx = particle->x[j] - particle->x[i-ii];[19;7H[32mconst[m [32mfloat[m dy = particle->y[j] - particle->y[i-ii];[20;7H[32mconst[m [32mfloat[m dz = particle->z[j] - particle->z[i-ii];[21;7H[32mconst[m [32mfloat[m drRecip  = [31m1.0f[m/sqrtf(dx*dx + dy*dy + dz*dz + [31m1e-20f[m);[22;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;

[1m-- INSERT --[m[50C24,1[10C20%[1;1H[?12l[?25h[?25l[27m[m[H[2J[1;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;[3;7H[34m// Calculate the net force[m[4;7HFx[i-ii] += dx * drPowerN32;[5;7HFy[i-ii] += dy * drPowerN32;[6;7HFz[i-ii] += dz * drPowerN32;[8;5H}
[33mfor[m([32mint[m i=ii;i<tileSize+ii;i++){
    [34m// Accelerate particles in response to the gravitational force[m
    particle->vx[i-ii] += dt*Fx[i];
    particle->vy[i] += dt*Fy[i];
    particle->vz[i] += dt*Fz[i];
}
  }
}
  [34m// Move particles according to their velocities
[m  [34m// O(N) work, so using a serial loop[m

  [33mfor[m ([32mint[m i = [31m0[m ; i < nParticles; i++) {
    particle->x[i]  += particle->vx[i]*dt;
    particle->y[i]  += particle->vy[i]*dt;
    particle->z[i]  += particle->vz[i]*dt;
[1m-- INSERT --[m[50C44,7[10C38%[1;7H[?12l[?25h[?25l[24;64H5,1[2;1H[?12l[?25h[?25l[24;64H6,7[3;7H[?12l[?25h[?25l[24;64H7[4;7H[?12l[?25h[?25l[24;64H8[5;7H[?12l[?25h[?25l[24;64H9[6;7H[?12l[?25h[?25l[24;63H50,1[7;1H[?12l[?25h[?25l[24;63H[K[24;63H51,6[10C38%[8;6H[?12l[?25h[?25l[24;64H2,7[9;7H[?12l[?25h[?25l[24;64H3[10;7H[?12l[?25h[?25l[24;64H4[11;7H[?12l[?25h[?25l[24;66H37[11;37H[?12l[?25h[?25l[24;67H6[11;36H[?12l[?25h[?25l[46m[[mi[46m][m[24;63H[K[24;63H54,35[9C38%[11;35H[?12l[?25h[?25l[24;67H4[11;34H[?12l[?25h[?25l[46m=[m];=[46m][m[24;67H5[11;35H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H6[11;36H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H7[11;37H[?12l[?25h[?25l][46m;[m [46m][m;[24;67H6[11;36H[?12l[?25h[?25l][46m;[m [46m][m;[24;67H5[11;35H[?12l[?25h[?25l][46m;[m [46m][m;[24;67H4[11;34H[?12l[?25h[?25l[46m-[m];-[46m][m[24;67H5[11;35H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H6[11;36H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H7[11;37H[?12l[?25h[?25l[i-ii][24;64H5,34[12;34H[?12l[?25h[?25l[24;67H3[12;33H[?12l[?25h[?25l[46m[[mi[46m][m[24;63H[K[24;63H55,32[9C38%[12;32H[?12l[?25h[?25l[24;67H1[12;31H[?12l[?25h[?25l[46m-[m];-[46m][m[24;67H2[12;32H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H3[12;33H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H4[12;34H[?12l[?25h[?25l[i-ii][24;64H6,33[13;33H[?12l[?25h[?25l[46m[[mi[46m][m[24;63H[K[24;63H56,32[9C38%[13;32H[?12l[?25h[?25l[24;67H1[13;31H[?12l[?25h[?25l[46m-[m];-[46m][m[24;67H2[13;32H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H3[13;33H[?12l[?25h[?25l[46mi[m];i[46m][m[24;67H4[13;34H[?12l[?25h[?25l[i-ii][24;67H3[13;33H[?12l[?25h[?25l[24;67H2[13;32H[?12l[?25h[?25l[24;67H1[13;31H[?12l[?25h[?25l[46m[[mi-ii[46m][m[24;63H[K[24;63H56,30[9C38%[13;30H[?12l[?25h[?25l[24;66H29[13;29H[?12l[?25h[?25l[i-ii][24;67H8[13;28H[?12l[?25h[?25l[24;67H7[13;27H[?12l[?25h[?25l[24;67H6[13;26H[?12l[?25h[?25l[24;67H5[13;25H[?12l[?25h[?25l[24;67H4[13;24H[?12l[?25h[?25l[24;67H3[13;23H[?12l[?25h[?25l[24;67H2[13;22H[?12l[?25h[?25l[24;67H1[13;21H[?12l[?25h[?25l[46m[[mi[46m][m[24;63H[K[24;63H56,20[9C38%[13;20H[?12l[?25h[?25l[24;66H19[13;19H[?12l[?25h[?25l[46m-[m] += dt*Fz[i-ii];[13;19H-[46m][m[24;66H20[13;20H[?12l[?25h[?25l[46mi[m] += dt*Fz[i-ii];[13;20Hi[46m][m[24;67H1[13;21H[?12l[?25h[?25l[46mi[m] += dt*Fz[i-ii];[13;21Hi[46m][m[24;67H2[13;22H[?12l[?25h[?25l[i-ii][24;64H5[12;22H[?12l[?25h[?25l[24;67H1[12;21H[?12l[?25h[?25l[46m[[mi[46m][m[24;63H[K[24;63H55,20[9C38%[12;20H[?12l[?25h[?25l[24;66H19[12;19H[?12l[?25h[?25l[46m-[m] += dt*Fy[i-ii];[12;19H-[46m][m[24;66H20[12;20H[?12l[?25h[?25l[46mi[m] += dt*Fy[i-ii];[12;20Hi[46m][m[24;67H1[12;21H[?12l[?25h[?25l[46mi[m] += dt*Fy[i-ii];[12;21Hi[46m][m[24;67H2[12;22H[?12l[?25h[24;1H[K[12;21H[?25l[i-ii][24;63H55,21[9C38%[12;21H[?12l[?25h[?25l[24;63H[K[24;1H:[?12l[?25hw[?25l[?12l[?25hq[?25l[?12l[?25h[?25l"nbody.cc" 135L, 4906C written
[?1l>[?12l[?25h[?1049l]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ vi nbody.ccmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  7.158e+01  6.000e+07      1.2 *
^Cmake: *** [run-cpu] Interrupt
make: *** Deleting intermediate file `nbody.o'

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ vi nbody.cc
[?1049h[?1h=[2;1H▽[6n[1;1H  [1;1H[1;24r[?12;25h[?12l[?25h[27m[m[H[2J[?25l[24;1H"nbody.cc" 135L, 4906C[>c[1;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;[3;7H[34m// Calculate the net force[m[4;7HFx[i-ii] += dx * drPowerN32;[5;7HFy[i-ii] += dy * drPowerN32;[6;7HFz[i-ii] += dz * drPowerN32;[8;5H}
[33mfor[m([32mint[m i=ii;i<tileSize+ii;i++){
    [34m// Accelerate particles in response to the gravitational force[m
    particle->vx[i-ii] += dt*Fx[i-ii];
    particle->vy[i-ii] += dt*Fy[i-ii];
    particle->vz[i-ii] += dt*Fz[i-ii];
}
  }
}
  [34m// Move particles according to their velocities
[m  [34m// O(N) work, so using a serial loop[m

  [33mfor[m ([32mint[m i = [31m0[m ; i < nParticles; i++) {
    particle->x[i]  += particle->vx[i]*dt;
    particle->y[i]  += particle->vy[i]*dt;
    particle->z[i]  += particle->vz[i]*dt;[24;63H55,5[10C38%[12;5H[?12l[?25h[?25l[24;64H6[13;5H[?12l[?25h[?25l[24;64H5[12;5H[?12l[?25h[?25l[24;64H4[11;5H[?12l[?25h[?25l[24;64H3[10;5H[?12l[?25h[?25l[24;64H2[9;5H[?12l[?25h[?25l[24;64H1[8;5H[?12l[?25h[?25l[24;64H0,0-1[7;1H[?12l[?25h[?25l[24;63H49,5  [6;5H[?12l[?25h[?25l[24;64H8[5;5H[?12l[?25h[?25l[24;64H9[6;5H[?12l[?25h[?25l[24;63H50,0-1[7;1H[?12l[?25h[?25l[24;64H1,5  [8;5H[?12l[?25h[?25l[24;64H2[9;5H[?12l[?25h[?25l[24;64H3[10;5H[?12l[?25h[?25l[24;64H4[11;5H[?12l[?25h[?25l[24;64H5[12;5H[?12l[?25h[?25l[24;64H6[13;5H[?12l[?25h[?25l[9;32H[46m{[14;1H}[m[24;64H7,1[14;1H[?12l[?25h[?25l[9;32H{[14;1H}[24;64H8,3[15;3H[?12l[?25h[?25l[24;64H9,1[16;1H[?12l[?25h[?25l[24;63H60,5[17;5H[?12l[?25h[?25l[24;64H1[18;5H[?12l[?25h[?25l[24;64H2,1[19;1H[?12l[?25h[?25l[24;64H3,5[20;5H[?12l[?25h[?25l[24;64H4[21;5H[?12l[?25h[?25l[24;64H5[22;5H[?12l[?25h[?25l[24;64H6[23;5H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[19;41H[46m{[23;3H}[m[24;1H[K[24;63H67,3[10C39%[23;3H[?12l[?25h[?25l[19;41H{[23;3H}[24;64H6,5[22;5H[?12l[?25h[?25l[24;64H5[21;5H[?12l[?25h[?25l[24;64H4[20;5H[?12l[?25h[?25l[24;64H3[19;5H[?12l[?25h[?25l[24;64H2,1[18;1H[?12l[?25h[?25l[24;64H1,5[17;5H[?12l[?25h[?25l[24;64H0[16;5H[?12l[?25h[?25l[24;63H59,1[15;1H[?12l[?25h[?25l[24;64H8,3[14;3H[?12l[?25h[?25l[8;32H[46m{[13;1H}[m[24;64H7,1[13;1H[?12l[?25h[?25l[8;32H{[13;1H}[24;64H6,5[12;5H[?12l[?25h[?25l[24;64H5[11;5H[?12l[?25h[?25l[24;64H4[10;5H[?12l[?25h[?25l[24;64H3[9;5H[?12l[?25h[?25l[24;64H2[8;5H[?12l[?25h[?25l[24;66H6[8;6H[?12l[?25h[?25l[24;66H7[8;7H[?12l[?25h[?25l[24;66H8[8;8H[?12l[?25h[?25l[24;66H9[8;9H[?12l[?25h[?25l[24;66H10[8;10H[?12l[?25h[?25l[24;67H1[8;11H[?12l[?25h[?25l[24;67H2[8;12H[?12l[?25h[?25l[24;67H3[8;13H[?12l[?25h[?25l[24;67H4[8;14H[?12l[?25h[?25l[24;67H5[8;15H[?12l[?25h[?25l[24;67H6[8;16H[?12l[?25h[?25l[24;1H[1m-- INSERT --[m[24;63H[K[24;63H52,16[9C39%[8;16H[?12l[?25h[?25litileSize+ii;i++){[24;67H7[8;17H[?12l[?25h[?25litileSize+ii;i++){[24;67H8[8;18H[?12l[?25h[?25l+tileSize+ii;i++){[24;67H9[8;19H[?12l[?25h[?25ltileSize+ii;i++){[8;35H[K[24;67H8[8;18H[?12l[?25h[?25ltileSize+ii;i++){[8;34H[K[24;67H7[8;17H[?12l[?25h[?25ltileSize+ii;i++){[8;33H[K[24;67H6[8;16H[?12l[?25h[?25l[24;64H3[9;16H[?12l[?25h[?25l[24;64H4[10;16H[?12l[?25h[?25l[24;64H3[9;16H[?12l[?25h[?25l[24;64H2[8;16H[?12l[?25h[?25l[24;63H[K[24;63H51,6[10C39%[7;6H[?12l[?25h[?25l[24;64H0,1[6;1H[?12l[?25h[?25l[24;63H49,16[5;16H[?12l[?25h[?25l[24;64H8[4;16H[?12l[?25h[?25l[24;64H7[3;16H[?12l[?25h[?25l[24;64H6[2;16H[?12l[?25h[?25l[24;64H5,2-9[1;9H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[32mconst[m [32mfloat[m drPowerN32  = drRecip*drRecip*drRecip;[24;63H[K[24;63H44,16[9C38%[1;16H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[32mconst[m [32mfloat[m drRecip  = [31m1.0f[m/sqrtf(dx*dx + dy*dy + dz*dz + [31m1e-20f[m);[24;63H[K[24;63H43,16[9C37%[1;16H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[32mconst[m [32mfloat[m dz = particle->z[j] - particle->z[i-ii];[24;63H[K[24;63H42,16[9C36%[1;16H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[32mconst[m [32mfloat[m dy = particle->y[j] - particle->y[i-ii];[24;63H[K[24;63H41,16[9C35%[1;16H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[32mconst[m [32mfloat[m dx = particle->x[j] - particle->x[i-ii];[24;63H[K[24;63H40,16[9C34%[1;16H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[34m// Newton's law of universal gravity[m[24;63H[K[24;63H39,16[9C33%[1;16H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[24;63H[K[24;63H38,1[10C33%[1;1H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[32mconst[m [32mfloat[m softening = [31m1e-20[m;[24;63H[K[24;63H37,16[9C32%[1;16H[?12l[?25h[?25l[24;64H8,1 [2;1H[?12l[?25h[?25l[24;64H9,16[3;16H[?12l[?25h[?25l[24;63H40[4;16H[?12l[?25h[?25l[24;67H7[4;17H[?12l[?25h[?25l[24;67H8[4;18H[?12l[?25h[?25l[24;67H9[4;19H[?12l[?25h[?25l[24;66H20[4;20H[?12l[?25h[?25l[24;67H1[4;21H[?12l[?25h[?25l[24;67H2[4;22H[?12l[?25h[?25l[24;67H3[4;23H[?12l[?25h[?25l[24;67H4[4;24H[?12l[?25h[?25l[24;67H5[4;25H[?12l[?25h[?25l[24;67H6[4;26H[?12l[?25h[?25l[24;67H7[4;27H[?12l[?25h[?25l[24;67H8[4;28H[?12l[?25h[?25l[24;67H9[4;29H[?12l[?25h[?25l[24;66H30[4;30H[?12l[?25h[?25l[24;67H1[4;31H[?12l[?25h[?25l[24;67H2[4;32H[?12l[?25h[?25l[24;67H3[4;33H[?12l[?25h[?25l[24;67H4[4;34H[?12l[?25h[?25lx[46m[[mj[46m][m[24;67H5[4;35H[?12l[?25h[?25l[24;63H[K[24;63H40,36[9C32%[4;36H[?12l[?25h[?25l[24;67H7[4;37H[?12l[?25h[?25l[24;63H[K[24;63H40,38[9C32%[4;38H[?12l[?25h[?25l[j][24;67H9[4;39H[?12l[?25h[?25l[24;66H40[4;40H[?12l[?25h[?25l[24;67H1[4;41H[?12l[?25h[?25l[24;67H2[4;42H[?12l[?25h[?25l[24;67H3[4;43H[?12l[?25h[?25l[24;67H4[4;44H[?12l[?25h[?25l[24;67H5[4;45H[?12l[?25h[?25l[24;67H6[4;46H[?12l[?25h[?25l[24;67H7[4;47H[?12l[?25h[?25l[24;67H8[4;48H[?12l[?25h[?25l[24;67H9[4;49H[?12l[?25h[?25l[24;66H50[4;50H[?12l[?25h[?25l[24;67H1[4;51H[?12l[?25h[?25lx[46m[[mi-ii[46m][m[24;67H2[4;52H[?12l[?25h[?25l[24;63H[K[24;63H40,53[9C32%[4;53H[?12l[?25h[?25l[i-ii][24;67H4[4;54H[?12l[?25h[?25l[24;67H5[4;55H[?12l[?25h[?25l[24;67H6[4;56H[?12l[?25h[?25l[46m[[mi-ii[46m][m[24;67H7[4;57H[?12l[?25h[?25l][46m;[m[4;58H[K[4;56H[46m][m;[24;67H6[4;56H[?12l[?25h[?25l][46m;[m[4;57H[K[4;55H[46m][m;[24;67H5[4;55H[?12l[?25h[?25l][46m;[m[4;56H[K[4;54H[46m][m;[24;67H4[4;54H[?12l[?25h[?25l[i][24;64H1[5;54H[?12l[?25h[?25l[24;67H5[5;55H[?12l[?25h[?25l[24;67H6[5;56H[?12l[?25h[?25l[46m[[mi-ii[46m][m[24;67H7[5;57H[?12l[?25h[?25l][46m;[m[5;58H[K[5;56H[46m][m;[24;67H6[5;56H[?12l[?25h[?25l][46m;[m[5;57H[K[5;55H[46m][m;[24;67H5[5;55H[?12l[?25h[?25l][46m;[m[5;56H[K[5;54H[46m][m;[24;67H4[5;54H[?12l[?25h[?25l[i][24;64H2[6;54H[?12l[?25h[?25l[24;67H5[6;55H[?12l[?25h[?25l[24;67H6[6;56H[?12l[?25h[?25l[46m[[mi-ii[46m][m[24;67H7[6;57H[?12l[?25h[?25l][46m;[m[6;58H[K[6;56H[46m][m;[24;67H6[6;56H[?12l[?25h[?25l][46m;[m[6;57H[K[6;55H[46m][m;[24;67H5[6;55H[?12l[?25h[?25l][46m;[m[6;56H[K[6;54H[46m][m;[24;67H4[6;54H[?12l[?25h[?25l[5;52H[46m[[mi[46m][m[6;52H[i][24;64H1[5;54H[?12l[?25h[?25l[4;52H[46m[[mi[46m][m[5;52H[i][24;64H0[4;54H[?12l[?25h[?25l[i][24;63H39,43[3;43H[?12l[?25h[?25l[24;64H8,1 [2;1H[?12l[?25h[?25l[24;64H7,37[1;37H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;7H[34m// Avoid singularity and interaction with self[m[24;63H[K[24;63H36,53[9C31%[1;53H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;9H[33mfor[m ([32mint[m i = ii; i < ii + tileSize; i++){[24;63H[K[24;63H35,47-54      30%[1;54H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5H[33mfor[m ([32mint[m j = [31m0[m; j < nParticles; j++) {[24;63H[K[24;63H34,44[9C29%[1;44H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;5H[34m// Loop over particles that exert force: vectorization expected here[m[24;63H[K[24;63H33,54[9C28%[1;54H[?12l[?25h[?25l[1;23r[1;1H[L[1;24r[1;1H[35m#pragma unroll(tileSize)      [m[24;63H[K[24;63H32,31[9C27%[1;31H[?12l[?25h[?25l[24;64H3,54[2;54H[?12l[?25h[?25l[24;64H4,4[3;44H[?12l[?25h[?25l[24;64H5,47-54[4;54H[?12l[?25h[?25l[24;64H6,53   [5;53H[?12l[?25h[?25l[24;64H5,47-54[4;54H[?12l[?25h[?25l[24;67H6-53[4;53H[?12l[?25h[?25l[24;67H5-52[4;52H[?12l[?25h[?25l[24;67H4-51[4;51H[?12l[?25h[?25l[46m{[20;5H}[m[24;63H[K[24;63H35,43-50      27%[4;50H[?12l[?25h[?25l[24;67H2-49[4;49H[?12l[?25h[?25l[24;63H[K[24;63H35,43-50      27%[4;50H[?12l[?25h[?25l{[20;5H}[24;64H4,44   [3;44H[?12l[?25h[?25l[24;63H[K[24;63H34,43[9C27%[3;43H[?12l[?25h[?25l[24;67H4[3;44H[?12l[?25h[?25l[24;64H5,37-44[4;44H[?12l[?25h[?25l[24;67H8-45[4;45H[?12l[?25h[?25l[24;67H9-46[4;46H[?12l[?25h[?25l[24;66H40-47[4;47H[?12l[?25h[?25l[4;13H[46m([34C)[m[24;67H1-48[4;48H[?12l[?25h[?25l[4;13H([34C)[46m{[20;5H}[m[24;67H2-49[4;49H[?12l[?25h[?25l{[20;5H}[24;64H4,44   [3;44H[?12l[?25h[?25l[24;63H[K[24;63H34,43[9C27%[3;43H[?12l[?25h[?25l[24;67H2[3;42H[?12l[?25h[?25l[24;64H5,35-42[4;42H[?12l[?25h[?25l[24;64H6,42   [5;42H[?12l[?25h[?25l[24;64H7,37[6;37H[?12l[?25h[?25l[24;64H8,1 [7;1H[?12l[?25h[?25l[24;64H9,42[8;42H[?12l[?25h[?25l[24;63H40[9;42H[?12l[?25h[?25l[24;64H1[10;42H[?12l[?25h[?25l[24;64H2[11;42H[?12l[?25h[?25l[24;64H3[12;42H[?12l[?25h[?25l[24;64H4[13;42H[?12l[?25h[?25l[24;64H5,2-9[14;9H[?12l[?25h[?25l[24;64H6,33 [15;33H[?12l[?25h[?25l[24;64H7,37[16;37H[?12l[?25h[?25l[24;64H8[17;37H[?12l[?25h[?25l[24;64H9,35[18;35H[?12l[?25h[?25l[24;63H50,1 [19;1H[?12l[?25h[?25l[4;49H[46m{[20;5H}[m[24;63H[K[24;63H51,6[10C27%[20;6H[?12l[?25h[?25l[21;23r[21;1H[L[1;24r[24;63H[K[24;63H52,1[10C27%[4;49H{[20;5H}
[?12l[?25h[?25l}[3;42H[46m{[21;1H}[m[24;63H[K[24;63H52,2[10C27%[21;2H[?12l[?25h[?25l[3;42H{[21;1H}[24;64H3[22;2H[?12l[?25h[?25l[24;64H4[23;2H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;5Hparticle->vx[i-ii] += dt*Fx[i-ii];[24;63H[K[24;63H55,2[10C28%[23;2H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;5Hparticle->vy[i-ii] += dt*Fy[i-ii];[24;63H[K[24;63H56,2[10C29%[23;2H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;5Hparticle->vz[i-ii] += dt*Fz[i-ii];[24;63H[K[24;63H57,2[10C30%[23;2H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;1H}[24;63H[K[24;63H58,2[10C30%[18;32H[46m{[23;1H}[m[24;63H[K[24;63H58,2[10C30%[23;2H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H}[24;63H[K[24;63H59,2[10C31%[17;32H{[22;1H}
 [?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;1H}[24;63H[K[24;63H60,2[10C32%[24;63H[K[24;63H60,2[10C32%[23;2H[?12l[?25h[?25l[1;23r[23;1H
[1;24r[23;3H[34m// Move particles according to their velocities[m[24;63H[K[24;63H61,2[10C33%[23;2H[?12l[?25h[?25l[24;63H[K[24;63H60,2[10C33%[22;2H[?12l[?25h[?25l[22;1H[K[24;66H1[22;1H[?12l[?25h[24;1H[K[22;1H[?25l[24;63H60,0-1[8C33%[22;1H[?12l[?25h[?25l[24;63H[K[24;1H:[?12l[?25hw[?25l[?12l[?25hq[?25l[?12l[?25h[?25l"nbody.cc" 136L, 4898C written
[?1l>[?12l[?25h[?1049l]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ vi nbody.ccmake run-cpu

Compiling a CPU object file:
icpc -c -qopenmp -mkl -xMIC-AVX512 -qopt-report -qopt-report-file=nbody.o.optrpt -o "nbody.o" "nbody.cc"

Linking the CPU executable:
icpc -qopenmp -mkl -xMIC-AVX512 -o app-CPU nbody.o
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  2.008e-01  2.139e+10    427.7 *
    2  3.722e-02  1.154e+11   2308.0 *
    3  3.716e-02  1.156e+11   2311.5 *
    4  3.688e-02  1.165e+11   2329.2 
    5  3.724e-02  1.153e+11   2306.4 
    6  3.802e-02  1.129e+11   2259.0 
    7  3.685e-02  1.166e+11   2331.2 
    8  3.685e-02  1.165e+11   2330.9 
    9  3.682e-02  1.166e+11   2332.6 
   10  3.690e-02  1.164e+11   2327.8 
-----------------------------------------------------
[1mAverage performance:      [42m    2316.7 +- 25.0 GFLOP/s[0m
-----------------------------------------------------
* - warm-up, not included in average

rm nbody.o
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ scro[Kipt Met[Kmort[KyTraffic.yx[K[Kr[Ktxt
Script started, file is MemoryTraffic.txt
Intel(R) Parallel Studio XE 2017 for Linux*
Copyright (C) 2009-2016 Intel Corporation. All rights reserved.
]0;test10@localhost:~/kmin/nbody[?1034h[test10@localhost nbody]$ make run-cpu
./app-CPU 65536

[1mNBODY Version 00[0m

Propagating 65536 particles using 1 thread on CPU...

[1m Step    Time, s Interact/s  GFLOP/s[0m
    1  2.025e-01  2.121e+10    424.3 *
    2  3.719e-02  1.155e+11   2309.7 *
    3  3.721e-02  1.154e+11   2308.2 *
    4  3.702e-02  1.160e+11   2320.0 
    5  3.699e-02  1.161e+11   2321.9 
    6  3.719e-02  1.155e+11   2309.7 
    7  3.709e-02  1.158e+11   2315.9 
    8  3.714e-02  1.156e+11   2312.8 
    9  3.707e-02  1.159e+11   2317.1 
   10  3.710e-02  1.158e+11   2315.2 
-----------------------------------------------------
[1mAverage performance:      [42m    2316.1 +- 3.8 GFLOP/s[0m
-----------------------------------------------------
* - warm-up, not included in average

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ exit
Script done, file is MemoryTraffic.txt
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git clone g[Khttps://github.com/Skmcarry/systemlecture[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Kgit init
Initialized empty Git repository in /home/test10/kmin/nbody/.git/
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git initscript MemoryTraffic.txt[16Pgit init[Kgit clone https://github.com/Skmcarry/systemlecture
Cloning into 'systemlecture'...
fatal: unable to access 'https://github.com/Skmcarry/systemlecture/': Could not resolve host: github.com; Name or service not known
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git clone https://github.com/Skmcarry/systemlecture[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Kgit clone https://github.com/Skmcarry/systemlecture.gi t
Cloning into 'systemlecture'...
fatal: unable to access 'https://github.com/Skmcarry/systemlecture.git/': Could not resolve host: github.com; Name or service not known
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ got[K[Kit remotr[Ke sys https://github.com/Skmcarry/systemlectu re.git
error: Unknown subcommand: sys
usage: git remote [-v | --verbose]
   or: git remote add [-t <branch>] [-m <master>] [-f] [--tags|--no-tags] [--mirror=<fetch|push>] <name> <url>
   or: git remote rename <old> <new>
   or: git remote remove <name>
   or: git remote set-head <name> (-a | -d | <branch>)
   or: git remote [-v | --verbose] show [-n] <name>
   or: git remote prune [-n | --dry-run] <name>
   or: git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)...]
   or: git remote set-branches [--add] <name> <branch>...
   or: git remote set-url [--push] <name> <newurl> [<oldurl>]
   or: git remote set-url --add <name> <newurl>
   or: git remote set-url --delete <name> <url>

    -v, --verbose         be verbose; must be placed before a subcommand

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git remote sys https://github.com/Skmcarry/systemlecturre.git[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C https://github.com/Skmcarry/systemlecture[1P.git[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C https://github.com/Skmcarry/systemlecture.[1Pgit[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C https://github.com/Skmcarry/systemlecture.g[1Pit[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Chttps://github.com/Skmcarry/systemlecture.gi[1Pt[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C

error: Unknown subcommand: https://github.com/Skmcarry/systemlecture.git
usage: git remote [-v | --verbose]
   or: git remote add [-t <branch>] [-m <master>] [-f] [--tags|--no-tags] [--mirror=<fetch|push>] <name> <url>
   or: git remote rename <old> <new>
   or: git remote remove <name>
   or: git remote set-head <name> (-a | -d | <branch>)
   or: git remote [-v | --verbose] show [-n] <name>
   or: git remote prune [-n | --dry-run] <name>
   or: git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)...]
   or: git remote set-branches [--add] <name> <branch>...
   or: git remote set-url [--push] <name> <newurl> [<oldurl>]
   or: git remote set-url --add <name> <newurl>
   or: git remote set-url --delete <name> <url>

    -v, --verbose         be verbose; must be placed before a subcommand

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git remote https://github.com/Skmcarry/systemlecture.giit[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Csys https://github.com/Skmcarry/systemlecture.git[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Chttps://github.com/Skmcarry/systemlecture.git[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cgit remote[K[K[K[K[K[Kclone [K[K[K[K[K[K[K[K[K[Kgit init https://github.com/Skmcarry/systemlecture.git [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Kt
Initialized empty Git repository in /home/test10/kmin/nbody/https:/github.com/Skmcarry/systemlecture.git/.git/
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git init https://github.com/Skmcarry/systemlecture.git [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cremote https://github.com/Skmcarry/systemlecture.giit
error: Unknown subcommand: https://github.com/Skmcarry/systemlecture.git
usage: git remote [-v | --verbose]
   or: git remote add [-t <branch>] [-m <master>] [-f] [--tags|--no-tags] [--mirror=<fetch|push>] <name> <url>
   or: git remote rename <old> <new>
   or: git remote remove <name>
   or: git remote set-head <name> (-a | -d | <branch>)
   or: git remote [-v | --verbose] show [-n] <name>
   or: git remote prune [-n | --dry-run] <name>
   or: git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)...]
   or: git remote set-branches [--add] <name> <branch>...
   or: git remote set-url [--push] <name> <newurl> [<oldurl>]
   or: git remote set-url --add <name> <newurl>
   or: git remote set-url --delete <name> <url>

    -v, --verbose         be verbose; must be placed before a subcommand

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git remote https://github.com/Skmcarry/systemlecture.giit[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cinit https://github.com/Skmcarry/systemlecture.git [K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P https://github.com/Skmcarry/systemlecture.git
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P https://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P https://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P https://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Phttps://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pttps://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pps://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pps://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Ps://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P://github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P//github.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pgithub.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pgithub.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pithub.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pthub.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Phub.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pub.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Pb.com/Skmcarry/systemlecture.git[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P.com/Skmcarry/systemlecture.git[1Pcom/Skmcarry/systemlecture.git[1Pom/Skmcarry/systemlecture.git[1Pm/Skmcarry/systemlecture.git[1P/Skmcarry/systemlecture.git[1PSkmcarry/systemlecture.git[1Pkmcarry/systemlecture.git[1Pmcarry/systemlecture.git[1Pcarry/systemlecture.git[1Parry/systemlecture.git[1Prry/systemlecture.git[C[1Py/systemlecture.git[1Py/systemlecture.git[1P/systemlecture.git[1Psystemlecture.git[1Pystemlecture.git[1Pstemlecture.git[1Ptemlecture.git[1Pemlecture.git[1Pmlecture.git[1Plecture.git[1Pecture.git[1Pcture.git[1Pture.git[1Pure.git[1Pre.git[1Pe.git[1P.git[1Pgit[1Pit[1Pt[Kinit
Reinitialized existing Git repository in /home/test10/kmin/nbody/.git/
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ go[K[Kgit add .
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git remote add https://github.com/Skmcarry/systemlectu re.git
usage: git remote add [<options>] <name> <url>

    -f, --fetch           fetch the remote branches
    --tags                import all tags and associated objects when fetching
                          or do not fetch any tag at all (--no-tags)
    -t, --track <branch>  branch(es) to track
    -m, --master <branch>
                          master branch
    --mirror[=<push|fetch>]
                          set up remote as a mirror to push to or fetch from

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git remotr[Ke add https://github.com/Skmcarry/systemlecturre.git -m
error: switch `m' requires a value
usage: git remote add [<options>] <name> <url>

    -f, --fetch           fetch the remote branches
    --tags                import all tags and associated objects when fetching
                          or do not fetch any tag at all (--no-tags)
    -t, --track <branch>  branch(es) to track
    -m, --master <branch>
                          master branch
    --mirror[=<push|fetch>]
                          set up remote as a mirror to push to or fetch from

]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ git push origin master
fatal: 'origin' does not appear to be a git repository
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
]0;test10@localhost:~/kmin/nbody[test10@localhost nbody]$ [K[test10@localhost nbody]$ [K[test10@localhost nbody]$ git
usage: git [--version] [--help] [-c name=value]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p|--paginate|--no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]

The most commonly used git commands are:
   add        Add file contents to the index
   bisect     Find by binary search the change that introduced a bug
   branch     List, create, or delete branches
   checkout   Checkout a branch or paths to the working tree
   clone      Clone a repository into a new directory
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   fetch      Download objects and refs from another repository
   grep       Print lines matching a pattern
   init       Create an empty Git repository or reinitialize an existing one
   log        Show commit logs
   merge      Join two or more developme